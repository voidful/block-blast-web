<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Block Blast — Flow+ 版</title>
<meta name="color-scheme" content="dark light" />
<style>
  *,*::before,*::after{ box-sizing: border-box; min-width: 0; }

  :root{
    --vh: 1svh;
    --board-size: clamp(320px, 90vmin, 720px);
    --gap: 6px;
    --tile-radius: 9px;
    --tray-cell: 28px;

    --bg: #0e1122;
    --panel: #151a2f;
    --text: #eef2ff;
    --muted: #a3acd6;
    --accent: #7aa2ff;

    --dur-pop: .14s; --dur-place: .16s; --dur-clear: .26s; --dur-toast: .8s;
    --ease-out: cubic-bezier(.22,.61,.36,1);
    --ease-back: cubic-bezier(.34,1.56,.64,1);
  }
  @media (prefers-reduced-motion: reduce) {
    :root{ --dur-pop:.06s; --dur-place:.08s; --dur-clear:.12s; --dur-toast:.5s; }
  }

  /* 一頁滿版、無捲動 */
  html, body { width:100%; height:100%; overflow:hidden; overscroll-behavior:none; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, "PingFang TC","Noto Sans TC","Microsoft JhengHei", Arial, sans-serif;
    background: radial-gradient(1200px 800px at 70% -20%, #1b2247 0%, var(--bg) 60%);
    color: var(--text);
    display:grid; place-items:center;
    background-attachment: fixed;
  }
  /* FEVER 視覺效果（不改排版） */
  body.is-fever .board{ box-shadow:0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px #2a2f55, inset 0 0 24px rgba(255,193,101,.28); }

  .app{
    width:min(1200px, 96vw);
    height: 100dvh;
    height: calc(var(--vh) * 100);
    max-height: 100dvh;
    max-height: calc(var(--vh) * 100);
    overflow:hidden;

    display:grid;
    grid-template-columns: 1fr minmax(0, var(--board-size)) 1fr;
    grid-template-areas:
      "header header header"
      ". board ."
      ". hold ."
      ". tray ."
      ". help .";
    grid-template-rows: auto 1fr auto auto auto;
    gap:16px;
    padding: 18px 0 calc(18px + env(safe-area-inset-bottom));
  }

  header{
    grid-area:header; display:flex; align-items:center; justify-content:space-between; gap:10px; padding:0 6px; flex-wrap:wrap;
    min-height: 56px;
  }
  .brand{ display:flex; align-items:center; gap:8px; font-weight:800; letter-spacing:.3px; color:#cfe1ff }
  .brand .dot{ width:10px; height:10px; border-radius:50%; background: var(--accent); box-shadow:0 0 12px rgba(122,162,255,.6) }

  .scorebox{ display:flex; gap:18px; align-items:baseline; flex-wrap:wrap }
  .label{ color:var(--muted); font-size:12px }
  .value{ font-size:22px; font-weight:800 }

  /* Header 內的 FEVER 區塊（非 body 狀態） */
  .fever{ display:flex; align-items:center; gap:8px; min-width:180px; }
  .fever-label{ font-weight:800; font-size:12px; letter-spacing:1px; color:#ffd08a }
  .fever-bar{ width:120px; height:10px; background:#0f1528; border:1px solid #5b3b16; border-radius:999px; overflow:hidden; box-shadow:0 0 10px rgba(255,193,101,.25) inset;}
  .fever-bar>i{ display:block; height:100%; width:0%; background:linear-gradient(90deg,#ffce6b,#ff7aa5); transition: width .15s }

  .combo{ display:flex; align-items:center; gap:8px; width:210px; flex:0 0 210px; }
  .combo .tag{
    display:inline-block; min-width:120px; text-align:center;
    font-weight:800; font-size:14px; color:#c8ffe6; background:#16352a;
    border:1px solid #2a5f4b; padding:4px 8px; border-radius:999px;
    transform-origin:left center; transition: transform .12s var(--ease-back), opacity .12s var(--ease-out), visibility 0s linear .12s;
    will-change: transform;
    visibility:hidden; opacity:0;
  }
  .combo .tag.show{ visibility:visible; opacity:1; transition-delay:0s; }
  .combo .bar{ width:120px; height:8px; background:#0f1528; border:1px solid #27305b; border-radius:999px; overflow:hidden }
  .combo .bar > i{ display:block; height:100%; width:0%; background: linear-gradient(90deg,#3ef0b4,#7aa2ff); transition: width .15s var(--ease-out) }

  .controls{ display:flex; gap:8px; flex-wrap:wrap }
  button{
    background: linear-gradient(180deg,#2a335f,#1b2143);
    border: 1px solid #2c376a;
    color: var(--text);
    padding: 10px 12px;
    border-radius: 10px; cursor: pointer; font-weight:700;
  }
  button:hover{ filter: brightness(1.06); }
  button.secondary{ background:#161c3c; border-color:#2a3568; color:#d7defa }
  button.ghost{ background:transparent; border-color:#2a3568 }
  .stars{ min-width:72px; text-align:right; color:#ffe28a; font-weight:800 }

  .board-wrap{
    grid-area:board;
    position:relative;
    display:grid; place-items:center;
    border-radius:16px;
    min-height: 0; min-width: 0;
    overflow:visible;
  }
  .board{
    width: var(--board-size); height: var(--board-size);
    background: linear-gradient(180deg,#12152a,#0d1021);
    border-radius:16px; padding: var(--gap);
    display:grid; grid-template-columns:repeat(10,1fr); grid-template-rows:repeat(10,1fr);
    gap:var(--gap); position:relative;
    box-shadow:0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px #2a2f55;
  }
  .cell{ position:relative; background:#141837; border-radius: calc(var(--tile-radius) - 2px); overflow:hidden; }
  .tile{ position:absolute; inset:0; border-radius:var(--tile-radius); transform:scale(0.98); transition: transform var(--dur-place) var(--ease-out); box-shadow: inset 0 -2px 0 rgba(0,0,0,.25); }
  .tile::after{ content:""; position:absolute; inset:0; background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(0,0,0,.08)); border-radius:inherit; pointer-events:none }
  .tile.appear{ animation: pop var(--dur-pop) var(--ease-back) }
  @keyframes pop{ from{ transform:scale(.2); opacity:0 } to{ transform:scale(.98); opacity:1 } }
  .tile.clearing{ animation: clear var(--dur-clear) var(--ease-out) forwards; }
  .tile.clearing[data-delay]{ animation-delay: var(--delay); }
  @keyframes clear{ 50%{ transform: scale(.85) } to{ transform: scale(.1); opacity:0 } }

  /* 幽靈/粒子層由 JS 精準對齊棋盤內容盒 */
  .ghost-layer, .fx-layer{
    position:absolute; left:0; top:0; width:0; height:0; pointer-events:none;
  }
  .ghost-cell{ position:absolute; border-radius:var(--tile-radius); opacity:.6; box-shadow: 0 0 0 2px rgba(122,162,255,.75) inset; background: rgba(122,162,255,.12); }
  .ghost-invalid{ box-shadow: 0 0 0 2px rgba(255,122,122,.85) inset; background: rgba(255,122,122,.12); }

  .heat-cell{ position:absolute; border-radius:8px; pointer-events:none; mix-blend-mode: screen; }

  .tray{ grid-area: tray; display:grid; grid-template-columns: 1fr 1fr 1fr; gap:14px; width: var(--board-size); margin: 0 auto 0; }
  .slot{ background: var(--panel); border-radius: 14px; min-height: 110px; padding: 10px; border: 1px solid #22284a; display:grid; place-items:center; position:relative; }
  .slot.empty::after{ content:"拖曳方塊到棋盤"; color:var(--muted); font-size:12px }

  .hold-row{ grid-area: hold; width: var(--board-size); margin: 0 auto 0; display:flex; align-items:center; gap:8px; justify-content:space-between; }
  .hold-slot{ background: var(--panel); border:1px dashed #2a3568; border-radius:12px; padding:8px; min-height:80px; display:grid; place-items:center; min-width:120px }
  .hold-label{ color:var(--muted); font-size:12px }

  .piece{ display:grid; gap:4px; grid-auto-rows: var(--tray-cell); grid-auto-columns: var(--tray-cell); touch-action:none; cursor:grab; }
  .piece:active{ cursor:grabbing; }
  .piece.grabbed{ transform: scale(1.06) rotate(-1.2deg); filter: drop-shadow(0 10px 20px rgba(0,0,0,.35)); transition: transform .08s var(--ease-back) }
  .cell-mini{ width: var(--tray-cell); height: var(--tray-cell); border-radius:7px; box-shadow: inset 0 -2px 0 rgba(0,0,0,.25); }

  .drag-proxy{ position: fixed; top: 0; left: 0; pointer-events: none; z-index: 9999; transform-origin: top left; will-change: transform; filter: drop-shadow(0 8px 18px rgba(0,0,0,.35)); }

  .overlay{ position:fixed; inset:0; display:grid; place-items:center; background: rgba(5,6,16,.68); backdrop-filter: blur(2px); opacity:0; pointer-events:none; transition: opacity .15s var(--ease-out) }
  .overlay.show{ opacity:1; pointer-events:auto; }
  .dialog{ background: linear-gradient(180deg,#20264b,#171c3a); border: 1px solid #303b74; border-radius:14px; padding:20px 18px; text-align:center; width:min(90vw, 480px); box-shadow: 0 20px 60px rgba(0,0,0,.5); max-height:min(86svh,520px); overflow:auto; }
  .dialog h2{ margin:4px 0 6px }
  .dialog p{ margin:6px 0 14px; color:var(--muted) }

  .toasts{ position:absolute; inset:0; pointer-events:none; }
  .toast{ position:absolute; transform: translate(-50%,-50%) translateY(0px); font-weight:900; color:#fff; text-shadow:0 2px 12px rgba(0,0,0,.4); animation: toast var(--dur-toast) var(--ease-out) forwards; will-change: transform, opacity; }
  @keyframes toast{ from{ opacity:0; transform: translate(-50%,-50%) translateY(10px) scale(.94) } 20%{ opacity:1 } to{ opacity:0; transform: translate(-50%,-80%) scale(1.06) } }

  .shake{ animation: shake .18s cubic-bezier(.36,.07,.19,.97) both; }
  @keyframes shake{
    10%, 90% { transform: translate3d(-1px, 1px, 0) }
    20%, 80% { transform: translate3d(2px, -2px, 0) }
    30%, 50%, 70% { transform: translate3d(-2px, 2px, 0) }
    40%, 60% { transform: translate3d(2px, -1px, 0) }
  }

  .help{ grid-area: help; width: var(--board-size); margin: 0 auto; color: var(--muted); font-size: 13px; line-height: 1.6; }
  .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0f1327; padding:2px 6px; border-radius:6px; border:1px solid #28305b }

  body.high-contrast .cell{ background:#0c0f24 }
  body.high-contrast .board{ box-shadow: 0 20px 60px rgba(0,0,0,.55), inset 0 0 0 2px #3b4381; }

  .board.hammer-cursor{ cursor: crosshair; }

  @media (max-width: 900px) and (orientation: portrait), (max-aspect-ratio: 3/4) {
    :root{ --board-size: min(68svh, 94vw); --tray-cell: clamp(22px, 7.2vmin, 34px); --gap: 5px; --tile-radius: 8px; }
    .app{
      width: 100vw;
      grid-template-columns: 1fr;
      grid-template-areas:
        "header"
        "board"
        "hold"
        "tray"
        "help";
      grid-template-rows: auto 1fr auto auto auto;
      gap: 10px;
      padding: 8px 0 calc(10px + env(safe-area-inset-bottom));
    }
    header{
      align-items: stretch; justify-content: flex-start; gap: 6px; padding: 0 10px; row-gap: 8px;
      display:grid; grid-template-columns: 1fr 1fr;
      min-height: unset;
    }
    .controls{
      grid-column: 1 / -1; width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch; white-space: nowrap; gap: 6px; padding: 6px 0; scrollbar-width: none;
    }
    .controls::-webkit-scrollbar{ display: none }
    .controls > button{ padding: 8px 10px; font-size: 12px; border-radius: 9px; }
    .combo{ width:auto; flex:1 1 auto; min-height:24px; }
    .combo .tag{ min-width:100px; }
    .board{ width: var(--board-size); height: var(--board-size); }
    .hold-row{ width: var(--board-size); justify-content: space-between; }
    .hold-slot{ min-height: 64px; padding: 6px; }
    .tray{ width: var(--board-size); grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .slot{ min-height: 90px; padding: 8px; }
    .help{ width: var(--board-size); font-size: 12px; line-height: 1.45; }
  }

  @media (max-height: 760px) { .help{ display:none; } }
  @media (max-height: 560px) {
    :root{ --gap: 4px; --tray-cell: 22px; }
    .slot{ min-height: 76px; padding: 6px; }
    .hold-slot{ min-height: 56px; padding: 6px; }
    .controls > button{ padding: 6px 8px; font-size: 12px; }
  }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand"><span class="dot"></span> Block Blast — Flow+ 版</div>

      <div class="scorebox">
        <div><div class="label">分數</div><div id="score" class="value">0</div></div>
        <div><div class="label">最高分</div><div id="best" class="value">0</div></div>
      </div>

      <div class="combo" aria-label="連擊狀態">
        <div id="comboTag" class="tag">COMBO ×1</div>
        <div class="bar"><i id="comboBar"></i></div>
      </div>

      <div class="fever"><div class="fever-label">FEVER</div><div class="fever-bar"><i id="feverFill"></i></div></div>
      <div class="stars">⭐ <b id="stars">0</b></div>

      <div class="controls">
        <button id="btn-undo" class="secondary">復原 ×3</button>
        <button id="btn-settings" class="ghost">⚙️</button>
        <button id="btn-daily" class="secondary">每日挑戰</button>
        <button id="btn-hint" class="secondary">提示</button>
        <button id="btn-tutorial" class="ghost">教學</button>
        <button id="btn-share" class="ghost">分享</button>
        <button id="btn-share-img" class="ghost">🖼️海報</button>
        <button id="btn-pass" class="ghost">🎯 Season</button>
        <button id="btn-mission" class="ghost">📜 任務</button>
        <button id="btn-new">新遊戲</button>
      </div>
    </header>

    <div class="board-wrap" id="boardWrap">
      <div id="board" class="board" aria-label="遊戲棋盤"></div>
      <div id="ghost" class="ghost-layer" aria-hidden="true"></div>
      <canvas id="fx" class="fx-layer"></canvas>
      <div class="toasts" id="toasts"></div>

      <div id="overlayGameOver" class="overlay">
        <div class="dialog">
          <h2>遊戲結束</h2>
          <p>本局分數 <b id="finalScore">0</b>。要不要再來一局？</p>
          <div style="display:flex; gap:8px; justify-content:center">
            <button id="btn-again">再玩一次</button>
            <button id="btn-close" class="secondary">關閉</button>
          </div>
        </div>
      </div>

      <div id="overlaySettings" class="overlay">
        <div class="dialog" style="text-align:left">
          <h2 style="text-align:center">設定</h2>
          <label><input type="checkbox" id="opt-audio" checked /> 啟用音效與音樂</label><br/>
          <label><input type="checkbox" id="opt-haptics" checked /> 啟用震動（行動裝置）</label><br/>
          <label><input type="checkbox" id="opt-reduce" /> 降低動態</label><br/>
          <label><input type="checkbox" id="opt-contrast" /> 高對比模式</label><br/>
          <label><input type="checkbox" id="opt-colorblind" /> 色盲友善調色</label><br/>
          <label><input type="checkbox" id="opt-hint" checked /> 閒置自動提示</label>
          <div style="margin-top:10px; display:flex; gap:8px; justify-content:center">
            <button id="btn-close-settings" class="secondary">關閉</button>
          </div>
        </div>
      </div>

      <div id="overlayPass" class="overlay">
        <div class="dialog" style="text-align:left">
          <h2 style="text-align:center">Season 1：Cosmetic Pass</h2>
          <div id="passList" style="max-height:40vh; overflow:auto"></div>
          <div style="text-align:center; margin-top:10px"><button id="btn-close-pass" class="secondary">關閉</button></div>
        </div>
      </div>

      <div id="overlayMission" class="overlay">
        <div class="dialog" style="text-align:left">
          <h2 style="text-align:center">任務</h2>
          <h3>每日</h3><div id="dailyList"></div>
          <h3>每週</h3><div id="weeklyList"></div>
          <div style="text-align:center; margin-top:10px"><button id="btn-close-mission" class="secondary">關閉</button></div>
        </div>
      </div>

      <div id="sr-live" aria-live="polite" style="position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden;"></div>
    </div>

    <div class="hold-row">
      <span class="hold-label">暫存（Hold）</span>
      <div id="holdSlot" class="hold-slot"></div>
      <div style="display:flex; gap:8px">
        <button id="btn-hammer" class="secondary" title="錘子：清除一格（花1⭐）">🔨</button>
        <button id="btn-shuffle" class="secondary" title="重抽托盤（花1⭐）">🔄</button>
        <button id="btn-hold" class="secondary" title="暫存格/取出">🧰</button>
      </div>
      <span id="dailyTag" class="label" style="margin-left:auto; display:none"></span>
    </div>

    <div id="tray" class="tray" aria-label="托盤（待放置方塊）">
      <div class="slot" data-index="0"></div>
      <div class="slot" data-index="1"></div>
      <div class="slot" data-index="2"></div>
    </div>

    <div class="help">
      <b>玩法</b>：拖曳托盤中的方塊到棋盤。填滿整列或整行會清除並加分。三個方塊都用完會再補三個。若托盤中任一方塊均無法放置，便判定失敗。<br>
      <b>操作</b>：拖曳放置；或以 <span class="kbd">1/2/3</span> 選塊、<span class="kbd">方向鍵</span> 移動、<span class="kbd">Space/Enter</span> 放置、<span class="kbd">Esc</span> 取消；<span class="kbd">U</span> 復原、<span class="kbd">N</span> 新遊戲、<span class="kbd">S</span> 設定、<span class="kbd">H</span> 熱度提示。
    </div>
  </div>

<script>
(function(){
  "use strict";

  const SIZE = 10;
  const STORAGE_KEY   = "blockblast_state_v9_ghost_lock";
  const SETTINGS_KEY  = "blockblast_settings_v4";
  const PALETTE_DEFAULT = ["#7aa2ff","#6ee7b7","#f472b6","#fbbf24","#34d399","#a78bfa","#f87171","#60a5fa","#22d3ee","#f59e0b"];
  const PALETTE_CVD     = ["#000000","#E69F00","#56B4E9","#009E73","#F0E442","#0072B2","#D55E00","#CC79A7"];

  const $ = sel => document.querySelector(sel);
  const $all = sel => Array.from(document.querySelectorAll(sel));
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const rnd = (arr, R=Math.random)=> arr[Math.floor(R()*arr.length)];
  const px = v => Math.round(v) + "px";
  function announce(msg){ const el=$("#sr-live"); if(!el) return; el.textContent=""; setTimeout(()=> el.textContent=msg, 10); }

  /* === 形狀 === */
  function shape(pattern){
    let coords=[];
    for(let y=0;y<pattern.length;y++){
      const row=pattern[y];
      for(let x=0;x<row.length;x++) if(row[x]!==' ') coords.push([x,y]);
    }
    const minX=Math.min(...coords.map(c=>c[0]));
    const minY=Math.min(...coords.map(c=>c[1]));
    coords=coords.map(([x,y])=>[x-minX,y-minY]);
    const w=Math.max(...coords.map(c=>c[0]))+1;
    const h=Math.max(...coords.map(c=>c[1]))+1;
    return { cells:coords, w, h, n:coords.length };
  }
  const SHAPES = [
    shape(["X"]),
    shape(["XX"]),shape(["XXX"]),shape(["XXXX"]),shape(["XXXXX"]),
    shape(["X","X"]),shape(["X","X","X"]),shape(["X","X","X","X"]),shape(["X","X","X","X","X"]),
    shape(["XX","XX"]),
    shape(["X ","XX"]), shape([" X","XX"]),
    shape(["X  ","XXX"]), shape(["  X","XXX"]),
    shape(["X ","X ","XX"]), shape([" X"," X","XX"]),
    shape(["XX "," XX"]), shape([" XX","XX "]),
    shape(["XXX"," X "]),
    shape(["X X","XXX"]),
    shape([" X ","XXX"," X "]),
  ];

  /* === RNG / Daily（保留掛勾） === */
  const RNG = { next: ()=> Math.random() };

  /* === 版面與 DOM === */
  const boardEl=$("#board"), ghostEl=$("#ghost"), boardWrap=$("#boardWrap"), fxCanvas=$("#fx");
  const scoreEl=$("#score"), bestEl=$("#best"), toastsEl=$("#toasts"), starsEl=$("#stars");
  const comboTag=$("#comboTag"), comboBar=$("#comboBar"), feverFill=$("#feverFill");

  function buildBoardUI(){ boardEl.innerHTML=""; for(let y=0;y<SIZE;y++){ for(let x=0;x<SIZE;x++){ const cell=document.createElement("div"); cell.className="cell"; cell.dataset.x=x; cell.dataset.y=y; const tile=document.createElement("div"); tile.className="tile"; tile.hidden=true; cell.appendChild(tile); boardEl.appendChild(cell); } } }
  function cellAt(x,y){ return boardEl.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`); }
  buildBoardUI();

  function innerOrigin(){ const rect=boardEl.getBoundingClientRect(); const pad=parseFloat(getComputedStyle(boardEl).paddingLeft) || 0; return { left: rect.left + pad, top: rect.top + pad, pad }; }
  function cellRectRel(x, y){
    if (x < 0 || y < 0 || x >= SIZE || y >= SIZE) return null;
    const r = cellAt(x,y).getBoundingClientRect();
    const o = innerOrigin();
    return { left:r.left-o.left, top:r.top-o.top, width:r.width, height:r.height, right:r.right-o.left, bottom:r.bottom-o.top };
  }
  function innerToWrap(ix, iy){
    const b = boardEl.getBoundingClientRect();
    const w = boardWrap.getBoundingClientRect();
    const pad = parseFloat(getComputedStyle(boardEl).paddingLeft) || 0;
    const dx = b.left - w.left, dy = b.top - w.top;
    return [ dx + pad + ix, dy + pad + iy ];
  }

  function cellIndexFromPoint(clientX, clientY){
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const r = cellAt(x,y).getBoundingClientRect();
        if(clientX >= r.left && clientX < r.right && clientY >= r.top && clientY < r.bottom){
          return { gx:x, gy:y };
        }
      }
    }
    return { gx:-1, gy:-1 };
  }

  function currentPalette(){ return state.settings.colorblind ? PALETTE_CVD : PALETTE_DEFAULT; }
  function pickPiece(){
    const base = SHAPES[Math.floor(RNG.next()*SHAPES.length)];
    const color = currentPalette()[Math.floor(RNG.next()*currentPalette().length)];
    return { cells:base.cells.map(([x,y])=>[x,y]), w:base.w, h:base.h, n:base.n, color, id:Math.random().toString(36).slice(2,9) };
  }

  /* === 狀態 === */
  function emptyBoard(){ return Array.from({length:SIZE}, ()=> Array(SIZE).fill(null)); }
  const state = {
    board: emptyBoard(), score:0, best:Number(localStorage.getItem("blockblast_best")||0),
    tray:[null,null,null], usedThisSet:0, history:[], gameOver:false,
    streak:0, lastActionAt:Date.now(), mode:"classic",
    fever:{ meter:0, active:false, until:0 },
    settings: loadSettings(),
    undoCharges: 3, undoMax:5,
    hintActive:false, awaitingHold:false,
    kb:{ active:false, selection:null, x:0, y:0 },
    dda:{ stress:0 },
    stars: 0, hold: null
  };

  function loadSettings(){
    const def={ audio:true, haptics:true, reduce: window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches, contrast:false, colorblind:false, hint:true };
    try{ const raw=localStorage.getItem(SETTINGS_KEY); if(!raw) return def; return {...def, ...JSON.parse(raw)}; }catch(e){ return def; }
  }
  function saveSettings(){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(state.settings)); }

  /* === HUD / 渲染 === */
  function renderHUD(){ scoreEl.textContent=state.score; bestEl.textContent=state.best; $("#btn-undo").textContent=`復原 ×${state.undoCharges}`; starsEl.textContent = state.stars; }
  function renderBoard(){
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
      const tile=cellAt(x,y).firstElementChild; const c=state.board[y][x];
      if(c){ tile.hidden=false; tile.style.background=c; } else { tile.hidden=true; tile.style.background="transparent"; tile.classList.remove("clearing","appear"); tile.style.removeProperty("--delay"); tile.removeAttribute("data-delay"); }
    }
    document.body.classList.toggle("high-contrast", !!state.settings.contrast);
    renderHUD();
  }
  function renderPieceInto(el, p){
    el.innerHTML=""; if(!p){ el.classList.add("empty"); return; } el.classList.remove("empty");
    const pieceEl=document.createElement("div"); pieceEl.className="piece";
    pieceEl.style.gridTemplateColumns=`repeat(${p.w}, var(--tray-cell))`;
    pieceEl.style.gridTemplateRows=`repeat(${p.h}, var(--tray-cell))`;
    p.cells.forEach(([x,y])=>{ const c=document.createElement("div"); c.className="cell-mini"; c.style.background=p.color; c.style.gridColumnStart=x+1; c.style.gridRowStart=y+1; pieceEl.appendChild(c); });
    el.appendChild(pieceEl); return pieceEl;
  }
  function renderHold(){
    const slot=$("#holdSlot"); slot.innerHTML="";
    if(!state.hold){ slot.textContent="（空）"; return; }
    const p=state.hold;
    const el=document.createElement("div"); el.className="piece";
    el.style.gridTemplateColumns=`repeat(${p.w}, var(--tray-cell))`;
    el.style.gridTemplateRows=`repeat(${p.h}, var(--tray-cell))`;
    p.cells.forEach(([x,y])=>{ const c=document.createElement("div"); c.className="cell-mini"; c.style.background=p.color; c.style.gridColumnStart=x+1; c.style.gridRowStart=y+1; el.appendChild(c); });
    slot.appendChild(el);
  }
  function renderTray(){
    $all(".slot").forEach(slot=>{ slot.innerHTML=""; slot.classList.add("empty"); });
    state.tray.forEach((p, idx)=>{
      const slot=document.querySelector(`.slot[data-index="${idx}"]`);
      if(!p){ slot.classList.add("empty"); return; }
      const pieceEl=renderPieceInto(slot, p);
      pieceEl.dataset.index=idx;
      pieceEl.addEventListener("pointerdown", onPiecePointerDown);
    });
    renderHold();
  }

  /* === 拖曳 / 幽靈 === */
  let drag=null; let hintBox=null;
  function clearGhost(){ ghostEl.innerHTML=""; $all(".heat-cell").forEach(n=>n.remove()); }
  function hideHint(){ if(hintBox){ hintBox.remove(); hintBox=null; } }

  function computeGrabOffset(e, pieceEl, piece){
    try {
      const rect = pieceEl.getBoundingClientRect();
      const gap  = parseFloat(getComputedStyle(pieceEl).gap) || 4;
      const cellEl = pieceEl.querySelector('.cell-mini');
      const cs   = cellEl ? cellEl.getBoundingClientRect().width : 24;
      const lx   = e.clientX - rect.left;
      const ly   = e.clientY - rect.top;
      let best = { x:0, y:0, d: Infinity };
      for (const [x, y] of piece.cells) {
        const cx = x * (cs + gap) + cs / 2;
        const cy = y * (cs + gap) + cs / 2;
        const d  = (lx - cx) * (lx - cx) + (ly - cy) * (ly - cy);
        if (d < best.d) best = { x, y, d };
      }
      return { sx: best.x, sy: best.y };
    } catch (err) {
      return { sx: 0, sy: 0 };
    }
  }
  function makeProxy(fromEl, grab){
    const proxy = fromEl.cloneNode(true);
    proxy.classList.add("drag-proxy");
    proxy.classList.remove("grabbed");
    proxy.style.opacity = 0.95;
    document.body.appendChild(proxy);
    const cellEl = proxy.querySelector('.cell-mini');
    const cs = cellEl ? cellEl.getBoundingClientRect().width : 24;
    const gap = parseFloat(getComputedStyle(proxy).gap) || 4;
    const offX = grab.sx * (cs + gap) + cs/2;
    const offY = grab.sy * (cs + gap) + cs/2;
    proxy.dataset.offX = offX;
    proxy.dataset.offY = offY;
    return proxy;
  }
  function moveProxy(x,y){
    if(!drag) return;
    const offX = parseFloat(drag.proxyEl.dataset.offX) || 20;
    const offY = parseFloat(drag.proxyEl.dataset.offY) || 20;
    drag.proxyEl.style.transform = `translate(${x - offX}px, ${y - offY}px)`;
  }

  function onPiecePointerDown(e){
    if(state.gameOver) return;
    const idx = Number(e.currentTarget.dataset.index);
    const piece = state.tray[idx];
    if(!piece) return;
    if(state.awaitingHold){
      state.awaitingHold=false;
      if(!state.hold){ state.hold = piece; state.tray[idx]=null; renderTray(); saveState(); }
      else { const tmp=state.hold; state.hold=piece; state.tray[idx]=tmp; renderTray(); saveState(); }
      return;
    }
    e.preventDefault(); e.stopPropagation();

    const grab = computeGrabOffset(e, e.currentTarget, piece);
    e.currentTarget.setPointerCapture(e.pointerId);
    e.currentTarget.classList.add("grabbed");

    const proxy = makeProxy(e.currentTarget, grab);
    drag={ piece, idx, proxyEl: proxy, grab };
    moveProxy(e.clientX, e.clientY);

    window.addEventListener("pointermove", onDragMove);
    window.addEventListener("pointerup", onDragEnd, { once:true });
    window.addEventListener("pointercancel", onDragCancel, { once:true });

    updateGhost(e.clientX, e.clientY);
    hideHint();
  }
  function onDragMove(e){ if(!drag) return; moveProxy(e.clientX,e.clientY); updateGhost(e.clientX,e.clientY); }
  function onDragEnd(e){
    if(!drag) return;
    const { piece, idx, anchor } = drag;
    $all(`.piece[data-index="${idx}"]`).forEach(el=>{
      try{ el.releasePointerCapture(e.pointerId); }catch(_){}
      el.classList.remove("grabbed");
    });
    if(anchor && anchor.ok){ commitPlacement(piece, idx, anchor.x, anchor.y); }
    try{ drag.proxyEl.remove(); }catch(_){}
    drag = null;
    clearGhost();
    window.removeEventListener("pointermove", onDragMove);
  }
  function onDragCancel(){
    if(!drag) return;
    try{ drag.proxyEl.remove(); }catch(_){}
    drag = null;
    clearGhost();
    window.removeEventListener("pointermove", onDragMove);
  }

  function updateGhost(clientX, clientY){
    clearGhost();
    const {gx, gy} = cellIndexFromPoint(clientX, clientY);
    if (gx < 0 || gy < 0) { drag.anchor = null; return; }
    const sx = (drag && drag.grab) ? drag.grab.sx : 0;
    const sy = (drag && drag.grab) ? drag.grab.sy : 0;
    const ax = gx - sx, ay = gy - sy;
    const { piece }=drag;
    const ok = canPlace(piece, ax, ay);

    piece.cells.forEach(([dx,dy])=>{
      const rr = cellRectRel(ax+dx, ay+dy);
      if (!rr) return;
      const ghost=document.createElement("div");
      ghost.className="ghost-cell "+(ok?"":"ghost-invalid");
      ghost.style.left  = px(rr.left);
      ghost.style.top   = px(rr.top);
      ghost.style.width = px(rr.width);
      ghost.style.height= px(rr.height);
      ghostEl.appendChild(ghost);
    });
    drag.anchor={ x:ax, y:ay, ok };
  }
  function canPlace(piece, x, y){
    for(const [dx,dy] of piece.cells){
      const cx=x+dx, cy=y+dy;
      if(cx<0||cx>=SIZE||cy<0||cy>=SIZE) return false;
      if(state.board[cy][cx]) return false;
    }
    return true;
  }

  /* === 分數 / 清行 / FEVER === */
  function addScore(delta){
    state.score += delta; if(state.score > state.best){ state.best=state.score; localStorage.setItem("blockblast_best", String(state.best)); }
    scoreEl.textContent=state.score; bestEl.textContent=state.best;
    announce(`分數 ${state.score}，最高分 ${state.best}`);
  }

  function findFullLines(){
    const rows=[], cols=[];
    for(let y=0;y<SIZE;y++) if(state.board[y].every(Boolean)) rows.push(y);
    for(let x=0;x<SIZE;x++){ let full=true; for(let y=0;y<SIZE;y++){ if(!state.board[y][x]){ full=false; break; } } if(full) cols.push(x); }
    return { rows, cols };
  }
  function animateAndClear(rows, cols){
    const toClear=[]; const cx=(SIZE-1)/2, cy=(SIZE-1)/2; const delayUnit=16;
    rows.forEach(y=>{ for(let x=0;x<SIZE;x++){ const d=Math.abs(x-cx)*delayUnit; const tile=cellAt(x,y).firstElementChild; tile.classList.add("clearing"); tile.style.setProperty("--delay", `${d}ms`); tile.setAttribute("data-delay",""); toClear.push([x,y,d]); }});
    cols.forEach(x=>{ for(let y=0;y<SIZE;y++){ const d=Math.abs(y-cy)*delayUnit; const tile=cellAt(x,y).firstElementChild; tile.classList.add("clearing"); tile.style.setProperty("--delay", `${d}ms`); tile.setAttribute("data-delay",""); toClear.push([x,y,d]); }});
    const maxDelay = toClear.reduce((m,c)=>Math.max(m,c[2]),0);
    setTimeout(()=>{ toClear.forEach(([x,y])=> state.board[y][x]=null); renderBoard(); saveState(); }, maxDelay+220);
    return toClear.map(([x,y])=>[x,y]);
  }

  let comboTimer=null, comboTimeMs=3500;
  function showCombo(){
    if(state.streak<=0){
      comboTag.classList.remove("show");
      comboBar.style.width="0%";
      return;
    }
    comboTag.classList.add("show");
    comboTag.textContent=`COMBO ×${state.streak}`;
    comboTag.style.transform="scale(1)";
    requestAnimationFrame(()=> comboTag.style.transform="scale(1.06)");
  }
  function startComboTimer(){
    const start=Date.now();
    if(comboTimer) clearInterval(comboTimer);
    comboTimer=setInterval(()=>{
      const p=clamp((Date.now()-start)/comboTimeMs,0,1);
      comboBar.style.width=`${(1-p)*100}%`;
      if(p>=1){ resetCombo(); }
    },100);
  }
  function resetCombo(){
    state.streak=0;
    comboBar.style.width="0%";
    comboTag.classList.remove("show");
    if(comboTimer) clearInterval(comboTimer), comboTimer=null;
  }

  function setFeverMeter(v){ state.fever.meter=Math.max(0,Math.min(100,v)); if(feverFill) feverFill.style.width=`${state.fever.meter}%`; saveState(); }
  function showToastAt(pxw,pyw,text,color="#fff"){
    const el=document.createElement("div"); el.className="toast"; el.textContent=text; el.style.left=`${pxw}px`; el.style.top=`${pyw}px`; el.style.color=color; toastsEl.appendChild(el); setTimeout(()=> el.remove(), 900);
  }
  function triggerFever(durationMs=15000){
    if(state.fever.active) return;
    state.fever.active=true; state.fever.until=Date.now()+durationMs; document.body.classList.add("is-fever");
    const b = boardEl.getBoundingClientRect(); const w = boardWrap.getBoundingClientRect();
    showToastAt((b.left-w.left)+boardEl.clientWidth/2, 24, "FEVER ×2!", "#ffd08a");
    requestAnimationFrame(tickFever);
  }
  function tickFever(){ if(!state.fever.active) return; if(Date.now()>=state.fever.until){ state.fever.active=false; document.body.classList.remove("is-fever"); setFeverMeter(0); } else { requestAnimationFrame(tickFever); } }

  function snapshotForUndo(){
    return { board: JSON.parse(JSON.stringify(state.board)), score:state.score, tray: JSON.parse(JSON.stringify(state.tray)), usedThisSet:state.usedThisSet, streak:state.streak, hold: JSON.parse(JSON.stringify(state.hold)), fever: JSON.parse(JSON.stringify(state.fever)) };
  }
  function grantUndoCharges(lines){ if(lines<=0) return; state.undoCharges = Math.min(5, state.undoCharges + lines); }

  function commitPlacement(piece, trayIdx, x, y){
    clearGhost();

    const prev = snapshotForUndo();
    piece.cells.forEach(([dx,dy])=>{ state.board[y+dy][x+dx] = piece.color; });
    piece.cells.forEach(([dx,dy])=>{
      const tile=cellAt(x+dx,y+dy).firstElementChild;
      tile.hidden=false; tile.style.background=piece.color;
      tile.classList.add("appear");
      setTimeout(()=>tile.classList.remove("appear"), 200);
    });

    state.tray[trayIdx]=null; state.usedThisSet++; renderTray();

    let gained = piece.n;
    const { rows, cols } = findFullLines();
    const linesCleared = rows.length + cols.length;
    if(linesCleared){
      animateAndClear(rows, cols);
      gained += 10*linesCleared + (linesCleared>1 ? 10*(linesCleared-1) : 0);
      setFeverMeter(state.fever.meter + linesCleared*25 + Math.min(10, piece.n));
      if(state.fever.meter >= 100) triggerFever();
    }
    if(state.fever.active) gained = Math.round(gained * 2);

    if(linesCleared>0){
      state.streak++; const comboBonus = state.streak*2; gained += comboBonus;
      showCombo(); startComboTimer();
    } else { resetCombo(); }

    addScore(gained);
    state.history.push(prev); if(state.history.length>50) state.history.shift();
    grantUndoCharges(linesCleared);

    if(state.usedThisSet >= 3) refillTrayFair();
    if(!hasAnyValidMove()) endGame();
    else { renderBoard(); updateStress(); saveState(); }

    state.lastActionAt=Date.now();
  }

  /* === DDA（簡）與抽牌 === */
  function features(){
    let filled=0; for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(state.board[y][x]) filled++;
    const density = filled/(SIZE*SIZE);
    let placements=0; for(const p of state.tray.filter(Boolean)){ for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(canPlace(p,x,y)) placements++; }
    return { density, placements };
  }
  function updateStress(){ const f=features(); const pNorm = 1 - Math.tanh(f.placements/24); const raw = 0.45*f.density + 0.35*pNorm; state.dda.stress = 0.85*state.dda.stress + 0.15*Math.min(1, Math.max(0, raw)); }
  function hasAnyValidMoveForTray(tray){ for(const p of tray){ if(!p) continue; for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(canPlace(p,x,y)) return true; } return false; }
  function refillTrayFair(){
    let pieces=[pickPiece(),pickPiece(),pickPiece()];
    let tries=0;
    while(!hasAnyValidMoveForTray(pieces) && tries<20){ pieces=[pickPiece(),pickPiece(),pickPiece()]; tries++; }
    state.tray=pieces; state.usedThisSet=0; renderTray(); saveState();
  }
  function hasAnyValidMove(){ return hasAnyValidMoveForTray(state.tray); }

  /* === 儲存 === */
  function saveState(){
    if(state.gameOver) return;
    const data={ board:state.board, score:state.score, tray:state.tray, usedThisSet:state.usedThisSet, best:state.best,
                 settings:state.settings, streak:state.streak, fever:state.fever, undoCharges:state.undoCharges,
                 stars:state.stars, hold:state.hold, mode:state.mode, dda:state.dda };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }
  function loadState(){
    const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return false;
    try{
      const d=JSON.parse(raw);
      state.board=d.board||emptyBoard(); state.score=d.score||0; state.tray=d.tray?.map(p=> p && {...p, cells:p.cells}) || [pickPiece(),pickPiece(),pickPiece()];
      state.usedThisSet=d.usedThisSet||0; if(typeof d.best==="number"){ state.best=d.best; localStorage.setItem("blockblast_best", String(state.best)); }
      state.settings=d.settings? {...state.settings, ...d.settings } : state.settings;
      state.streak=d.streak||0; state.fever=d.fever||state.fever; state.undoCharges=d.undoCharges ?? state.undoCharges;
      state.stars=d.stars ?? 0; state.hold=d.hold || null; state.mode=d.mode||"classic";
      return true;
    }catch(e){ return false; }
  }

  /* === 幽靈層對齊 & 尺寸 === */
  const fx = { ctx: fxCanvas.getContext("2d"), parts:[], last:0, dpr:1 };
  function positionOverlayLayers(){
    const b = boardEl.getBoundingClientRect();
    const w = boardWrap.getBoundingClientRect();
    const pad = parseFloat(getComputedStyle(boardEl).paddingLeft) || 0;
    const L = (b.left - w.left + pad);
    const T = (b.top  - w.top  + pad);
    const W = b.width  - pad*2;
    const H = b.height - pad*2;
    ghostEl.style.left = px(L); ghostEl.style.top  = px(T); ghostEl.style.width  = px(W); ghostEl.style.height = px(H);
    fxCanvas.style.left = px(L); fxCanvas.style.top = px(T); fxCanvas.style.width = px(W); fxCanvas.style.height = px(H);
    const dpr=Math.min(2, window.devicePixelRatio||1);
    fxCanvas.width  = Math.round(W * dpr);
    fxCanvas.height = Math.round(H * dpr);
    fx.dpr=dpr;
    clearGhost();
  }

  function updateVHVar(){
    const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight) * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  function fitFullscreen(){
    updateVHVar();
    requestAnimationFrame(()=>{
      const wrap = document.getElementById('boardWrap');
      const rect = wrap.getBoundingClientRect();
      const size = Math.floor(Math.min(rect.width, rect.height));
      document.documentElement.style.setProperty('--board-size', Math.max(0,size) + 'px');
      positionOverlayLayers();
    });
  }
  function bindFitEvents(){
    const rerun = () => fitFullscreen();
    window.addEventListener('resize', rerun, { passive: true });
    window.addEventListener('orientationchange', rerun, { passive: true });
    if (window.visualViewport) window.visualViewport.addEventListener('resize', rerun, { passive: true });
    if (document.fonts && document.fonts.ready) document.fonts.ready.then(rerun);
    rerun();
  }

  /* === 事件 === */
  $("#btn-new").addEventListener("click", newGame);
  $("#btn-again").addEventListener("click", newGame);
  $("#btn-close").addEventListener("click", ()=> $("#overlayGameOver").classList.remove("show"));
  $("#btn-undo").addEventListener("click", ()=>{
    if(!state.history.length||state.undoCharges<=0) return;
    const prev=state.history.pop(); state.undoCharges--;
    state.board=prev.board; state.score=prev.score; state.tray=prev.tray; state.usedThisSet=prev.usedThisSet; state.streak=prev.streak; state.hold=prev.hold; state.fever=prev.fever;
    renderBoard(); renderTray(); renderHUD(); saveState();
  });

  $("#btn-settings").addEventListener("click", ()=> { $("#overlaySettings").classList.add("show"); });
  $("#btn-close-settings").addEventListener("click", ()=> { $("#overlaySettings").classList.remove("show"); saveSettings(); });

  $("#opt-audio").addEventListener("change", e=>{ state.settings.audio=e.target.checked; saveSettings(); });
  $("#opt-haptics").addEventListener("change", e=>{ state.settings.haptics=e.target.checked; saveSettings(); });
  $("#opt-reduce").addEventListener("change", e=>{ state.settings.reduce=e.target.checked; saveSettings(); });
  $("#opt-contrast").addEventListener("change", e=>{ state.settings.contrast=e.target.checked; document.body.classList.toggle("high-contrast", e.target.checked); saveSettings(); });
  $("#opt-colorblind").addEventListener("change", e=>{ state.settings.colorblind=e.target.checked; renderTray(); saveSettings(); });
  $("#opt-hint").addEventListener("change", e=>{ state.settings.hint=e.target.checked; saveState(); });

  $("#btn-hold").addEventListener("click", ()=>{
    if(state.hold && state.tray[0]){ const tmp=state.tray[0]; state.tray[0]=state.hold; state.hold=tmp; renderTray(); saveState(); }
    else{ state.awaitingHold=true; announce("點托盤任一方塊以暫存／交換"); }
  });

  function newGame(){
    state.board=emptyBoard(); state.score=0; state.tray=[null,null,null]; state.usedThisSet=0; state.history=[]; state.gameOver=false;
    state.streak=0; setFeverMeter(0); document.body.classList.remove("is-fever"); state.undoCharges=3;
    refillTrayFair(); renderBoard(); renderTray(); saveState(); state.lastActionAt=Date.now();
  }
  function endGame(){
    state.gameOver=true; $("#finalScore").textContent=state.score; $("#overlayGameOver").classList.add("show");
    announce(`遊戲結束。本局 ${state.score} 分。`);
  }

  /* === 啟動 === */
  const loaded = loadState(); if(!loaded) refillTrayFair();
  renderBoard(); renderTray(); if(feverFill) feverFill.style.width=`${state.fever.meter}%`;
  bindFitEvents();

  /* 基本鍵盤操作（選塊/移動/放置） */
  window.addEventListener("keydown", (e)=>{
    if(e.key==='n'||e.key==='N') newGame();
    if(e.key==='u'||e.key==='U') $("#btn-undo").click();
    if(e.key==='1'||e.key==='2'||e.key==='3'){
      const i=Number(e.key)-1; if(state.tray[i]){ state.kb.active=true; state.kb.selection=i; state.kb.x=0; state.kb.y=0; clearGhost(); }
    }
    if(e.key==='Escape'){ state.kb.active=false; state.kb.selection=null; clearGhost(); }
    if(state.kb.active){
      const p=state.tray[state.kb.selection]; if(!p) return;
      if(e.key==='ArrowLeft')  state.kb.x=Math.max(0, state.kb.x-1);
      if(e.key==='ArrowRight') state.kb.x=Math.min(SIZE-p.w, state.kb.x+1);
      if(e.key==='ArrowUp')    state.kb.y=Math.max(0, state.kb.y-1);
      if(e.key==='ArrowDown')  state.kb.y=Math.min(SIZE-p.h, state.kb.y+1);

      if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)){
        clearGhost();
        const ok=canPlace(p, state.kb.x, state.kb.y);
        p.cells.forEach(([dx,dy])=>{
          const rr = cellRectRel(state.kb.x + dx, state.kb.y + dy);
          if(!rr) return;
          const cell=document.createElement("div");
          cell.className="ghost-cell "+(ok?"":"ghost-invalid");
          cell.style.left = px(rr.left);
          cell.style.top  = px(rr.top);
          cell.style.width  = px(rr.width);
          cell.style.height = px(rr.height);
          ghostEl.appendChild(cell);
        });
      }
      if(e.key===' '||e.key==='Enter'){ const {x,y}=state.kb; if(canPlace(p,x,y)){ commitPlacement(p, state.kb.selection, x,y); state.kb.active=false; clearGhost(); } }
    }
  });

})();
</script>
</body>
</html>
