<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Block Blast — Flow+ 版</title>
<meta name="color-scheme" content="dark light" />
<style>
  *,*::before,*::after{ box-sizing:border-box; min-width:0; }

  :root{
    --vh: 1svh;
    --grid-size: 8;                 /* 8×8 棋盤 */
    --board-size: 560px;            /* 由 JS 依視窗更新 */
    --gap: 6px;
    --tile-radius: 9px;
    --tray-cell: 30px;

    /* 槽位固定高度，候選只縮放，不改槽位高 */
    --tray-slot-h: calc(var(--tray-cell) * 3.4 + 24px);
    --hold-slot-h:  calc(var(--tray-cell) * 2.6 + 16px);

    /* 候選縮放參數 */
    --tray-fill: 0.94;
    --tray-scale-max: 1.8;

    --bg: #0e1122;
    --panel: #151a2f;
    --text: #eef2ff;
    --muted: #a3acd6;
    --accent: #7aa2ff;

    --dur-pop:.14s; --dur-place:.16s; --dur-clear:.26s; --dur-toast:.8s;
    --ease-out:cubic-bezier(.22,.61,.36,1);
    --ease-back:cubic-bezier(.34,1.56,.64,1);
  }
  @media (prefers-reduced-motion: reduce){
    :root{ --dur-pop:.06s; --dur-place:.08s; --dur-clear:.12s; --dur-toast:.5s; }
  }

  /* 一頁滿版、無捲動；svh 兼容 iOS */
  html,body{ width:100%; height:100%; overflow:hidden; overscroll-behavior:none; }
  @supports (height:100svh){ html,body{ height:100svh; } }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, "PingFang TC","Noto Sans TC","Microsoft JhengHei", Arial, sans-serif;
    background: radial-gradient(1200px 800px at 70% -20%, #1b2247 0%, var(--bg) 60%);
    color:var(--text);
    display:grid; place-items:center;
    background-attachment:fixed;
  }

  body.is-fever .board{
    box-shadow:0 20px 60px rgba(0,0,0,.45),
               inset 0 0 0 1px #2a2f55,
               inset 0 0 24px rgba(255,193,101,.28);
  }

  /* ====== 版面：直向（上下結構） ====== */
  .app{
    width:min(1200px,96vw);
    height:calc(var(--vh)*100);
    overflow:hidden;
    display:grid;
    grid-template-columns:1fr minmax(0,var(--board-size)) 1fr;
    grid-template-areas:
      "header header header"
      ". board ."
      ". hold ."
      ". tray ."
      ". help .";
    grid-template-rows:auto auto auto auto auto;
    gap:16px;
    padding:16px 0 calc(16px + env(safe-area-inset-bottom));
  }
  @supports (height:100svh){ .app{ height:100svh; } }

  header{
    grid-area:header; display:flex; align-items:center; justify-content:space-between; gap:10px; padding:0 8px; flex-wrap:wrap;
    min-height:56px;
  }
  .brand{ display:flex; align-items:center; gap:8px; font-weight:800; letter-spacing:.3px; color:#cfe1ff }
  .brand .dot{ width:10px; height:10px; border-radius:50%; background:var(--accent); box-shadow:0 0 12px rgba(122,162,255,.6) }

  .scorebox{ display:flex; gap:18px; align-items:baseline; flex-wrap:wrap }
  .label{ color:var(--muted); font-size:12px }
  .value{ font-size:22px; font-weight:800 }

  .fever{ display:flex; align-items:center; gap:8px; min-width:180px; }
  .fever-label{ font-weight:800; font-size:12px; letter-spacing:1px; color:#ffd08a }
  .fever-bar{
    position:relative; width:170px; height:10px;
    background:#0f1528; border:1px solid #5b3b16; border-radius:999px;
    overflow:hidden; box-shadow:0 0 10px rgba(255,193,101,.25) inset;
  }
  /* transform 版，不重排 */
  .fever-bar>i{ display:block; height:100%; width:100%; transform-origin:left center; transform:scaleX(var(--fever,0)); background:linear-gradient(90deg,#ffce6b,#ff7aa5); transition:transform .15s; }
  .fever-sweep{
    position:absolute; top:-60%; bottom:-60%;
    background:linear-gradient(90deg,rgba(255,255,255,0),rgba(255,236,180,.9),rgba(255,255,255,0));
    filter:blur(3px); mix-blend-mode:screen; opacity:.9; pointer-events:none;
  }

  .combo{ display:flex; align-items:center; gap:8px; width:210px; flex:0 0 210px; }
  .combo .tag{
    display:inline-block; min-width:120px; text-align:center;
    font-weight:800; font-size:14px; color:#c8ffe6; background:#16352a;
    border:1px solid #2a5f4b; padding:4px 8px; border-radius:999px;
    transform-origin:left center; transition: transform .12s var(--ease-back), opacity .12s var(--ease-out), visibility 0s linear .12s;
    visibility:hidden; opacity:0;
  }
  .combo .tag.show{ visibility:visible; opacity:1; transition-delay:0s; }
  .combo .bar{ width:120px; height:8px; background:#0f1528; border:1px solid #27305b; border-radius:999px; overflow:hidden }
  .combo .bar>i{ display:block; height:100%; width:0%; background:linear-gradient(90deg,#3ef0b4,#7aa2ff); transition:width .15s var(--ease-out) }

  .controls{ display:flex; gap:8px; flex-wrap:wrap }
  button{
    background:linear-gradient(180deg,#2a335f,#1b2143);
    border:1px solid #2c376a;
    color:var(--text);
    padding:10px 12px;
    border-radius:10px; cursor:pointer; font-weight:700;
  }
  button.secondary{ background:#161c3c; border-color:#2a3568; color:#d7defa }
  button.ghost{ background:transparent; border-color:#2a3568 }
  .stars{ min-width:72px; text-align:right; color:#ffe28a; font-weight:800 }

  .board-wrap{ grid-area:board; position:relative; display:grid; place-items:center; border-radius:16px; overflow:visible; }
  .board{
    width:var(--board-size); height:var(--board-size);
    background:linear-gradient(180deg,#12152a,#0d1021);
    border-radius:16px; padding:var(--gap);
    display:grid; grid-template-columns:repeat(var(--grid-size),1fr); grid-template-rows:repeat(var(--grid-size),1fr);
    gap:var(--gap); position:relative;
    box-shadow:0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px #2a2f55;
    contain:layout paint size;
  }
  .cell{ position:relative; background:#141837; border-radius:calc(var(--tile-radius) - 2px); overflow:hidden; }
  /* === Highlight：抓取格對齊位置的視覺準星 */
  .cell.highlight{ outline:2px solid rgba(122,162,255,.85); outline-offset:-2px; box-shadow:0 0 0 2px rgba(122,162,255,.25) inset; }

  .tile{ position:absolute; inset:0; border-radius:var(--tile-radius); transform:scale(0.98); transition:transform var(--dur-place) var(--ease-out); box-shadow:inset 0 -2px 0 rgba(0,0,0,.25); }
  .tile::after{ content:""; position:absolute; inset:0; background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(0,0,0,.08)); border-radius:inherit; pointer-events:none }
  .tile.appear{ animation:pop var(--dur-pop) var(--ease-back) }
  @keyframes pop{ from{transform:scale(.2); opacity:0} to{transform:scale(0.98); opacity:1} }
  .tile.clearing{ animation:clear var(--dur-clear) var(--ease-out) forwards }
  .tile.clearing[data-delay]{ animation-delay:var(--delay) }
  @keyframes clear{ 50%{transform:scale(.85)} to{transform:scale(.1); opacity:0} }

  .ghost-layer,.fx-layer{ position:absolute; left:0; top:0; width:0; height:0; pointer-events:none; contain:layout paint size; }
  .ghost-cell{ position:absolute; border-radius:var(--tile-radius); opacity:.6; box-shadow:0 0 0 2px rgba(74,222,128,.9) inset; background:rgba(74,222,128,.14) }
  .ghost-invalid{ box-shadow:0 0 0 2px rgba(255,122,122,.85) inset; background:rgba(255,122,122,.12) }

  .hold-row{
    grid-area:hold;
    width:var(--board-size);
    margin:0 auto;
    display:grid;
    grid-template-columns:auto 1fr auto auto auto;
    align-items:center; gap:10px; color:var(--muted);
    padding:0 8px;
  }
  .hold-label{ font-weight:800; letter-spacing:.3px; color:#cfe1ff }
  .hold-slot{
    background:var(--panel); border:1px solid #22284a; border-radius:14px;
    height:var(--hold-slot-h); min-height:var(--hold-slot-h); position:relative; overflow:hidden;
  }

  .tray{
    grid-area:tray;
    display:grid; grid-template-columns:1fr 1fr 1fr; gap:14px;
    width:var(--board-size); margin:0 auto 0;
  }
  .slot{
    background:var(--panel); border-radius:14px; padding:10px; border:1px solid #22284a;
    position:relative; height:var(--tray-slot-h); min-height:var(--tray-slot-h); max-height:var(--tray-slot-h);
    overflow:hidden; display:block;
  }
  .slot.empty::after{ content:"拖曳方塊到棋盤"; color:var(--muted); font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:90%; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); }
  .slot.hint{ box-shadow:0 0 0 2px #4ade80 inset }

  /* FEVER 期間托盤脈動光暈（視覺效果） */
  @keyframes trayPulse {
    0%,100% { opacity:.65; transform:scale(1); filter: drop-shadow(0 0 10px rgba(255,160,122,.35)); }
    50%     { opacity:1;   transform:scale(1.02); filter: drop-shadow(0 0 20px rgba(255,160,122,.7)); }
  }
  body.is-fever .tray .slot::after{
    content:""; position:absolute; inset:0; border-radius:inherit; pointer-events:none;
    background: radial-gradient(160px 42px at 50% 100%, rgba(255,193,101,.22), transparent 70%);
    animation: trayPulse 1.1s ease-in-out infinite;
  }

  /* 托盤置中：slot → pwrap(relative) → pinner(abs center) → piece(scale) */
  .pwrap{ position:relative; width:100%; height:100%; overflow:hidden; }
  .pinner{
    position:absolute; left:50%; top:50%;
    transform:translate(-50%,-50%) scale(var(--mag,1));
    transition: transform .12s var(--ease-back), filter .12s var(--ease-out);
    display:grid; place-items:center;
  }
  .slot.hover-mag .pinner{ --mag:1.03; filter: drop-shadow(0 6px 14px rgba(0,0,0,.34)); }
  .slot:hover .pinner{ --mag:1.03; filter: drop-shadow(0 6px 14px rgba(0,0,0,.34)); }

  .piece{ display:grid; gap:4px; grid-auto-rows:var(--tray-cell); grid-auto-columns:var(--tray-cell); touch-action:none; cursor:grab; transform-origin:center center; will-change:transform }
  .piece:active{ cursor:grabbing }
  .piece.grabbed{ transform:scale(1.06) rotate(-1.2deg); filter:drop-shadow(0 10px 20px rgba(0,0,0,.35)); transition:transform .08s var(--ease-back) }
  .cell-mini{ width:var(--tray-cell); height:var(--tray-cell); border-radius:7px; box-shadow:inset 0 -2px 0 rgba(0,0,0,.25) }

  .drag-proxy,.guide-proxy{ position:fixed; top:0; left:0; pointer-events:none; z-index:9999; transform-origin:top left; will-change:transform; filter:drop-shadow(0 8px 18px rgba(0,0,0,.35)) }

  .overlay{ position:fixed; inset:0; display:grid; place-items:center; background:rgba(5,6,16,.68); backdrop-filter:blur(2px); opacity:0; pointer-events:none; transition:opacity .15s var(--ease-out) }
  .overlay.show{ opacity:1; pointer-events:auto }
  .dialog{ background:linear-gradient(180deg,#20264b,#171c3a); border:1px solid #303b74; border-radius:14px; padding:20px 18px; text-align:center; width:min(90vw,480px); box-shadow:0 20px 60px rgba(0,0,0,.5); max-height:min(86svh,520px); overflow:auto }
  .dialog h2{ margin:4px 0 6px }
  .dialog p{ margin:6px 0 14px; color:var(--muted) }

  .toasts{ position:absolute; inset:0; pointer-events:none }
  .toast{ position:absolute; transform:translate(-50%,-50%) translateY(0px); font-weight:900; color:#fff; text-shadow:0 2px 12px rgba(0,0,0,.4); animation:toast var(--dur-toast) var(--ease-out) forwards; }
  @keyframes toast{ from{opacity:0; transform:translate(-50%,-50%) translateY(10px) scale(.94)} 20%{opacity:1} to{opacity:0; transform:translate(-50%,-80%) scale(1.06)} }

  /* 星星飛行特效 */
  .star-fly{ position:fixed; left:0; top:0; pointer-events:none; z-index:10000; will-change:transform,opacity; font-size:18px; filter:drop-shadow(0 0 6px rgba(255,200,90,.7)); }

  .help{ grid-area:help; width:var(--board-size); margin:0 auto; color:var(--muted); font-size:13px; line-height:1.6; content-visibility:auto; contain-intrinsic-size:400px; }

  .board.hammer-cursor{ cursor:crosshair }

  /* 降噪模式：低於 45fps 時弱化重陰影與玻璃亮片 */
  body.lowfx .board{ box-shadow:0 12px 32px rgba(0,0,0,.35), inset 0 0 0 1px #2a2f55 }
  body.lowfx .tile{ box-shadow:inset 0 -1px 0 rgba(0,0,0,.2) }
  body.lowfx .tile::after{ background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(0,0,0,.03)) }
  body.lowfx .slot:hover .pinner{ --mag:1.01; filter:none }

  /* 直向手機：控制列水平捲動避免撐高 */
  @media (max-width:900px) and (orientation:portrait), (max-aspect-ratio:3/4){
    :root{ --board-size:min(70svh,94vw); --tray-cell:clamp(22px,7.2vmin,34px); --gap:5px; --tile-radius:8px; }
    .app{
      width:100vw;
      grid-template-columns:1fr;
      grid-template-areas:"header" "board" "hold" "tray" "help";
      gap:10px; padding:8px 0 calc(10px + env(safe-area-inset-bottom));
    }
    header{ align-items:stretch; justify-content:flex-start; gap:6px; padding:0 10px; row-gap:8px; display:grid; grid-template-columns:1fr 1fr; min-height:unset; }
    .controls{ grid-column:1/-1; width:100%; overflow-x:auto; -webkit-overflow-scrolling:touch; white-space:nowrap; gap:6px; padding:6px 0; scrollbar-width:none }
    .controls::-webkit-scrollbar{ display:none }
    .controls>button{ padding:8px 10px; font-size:12px; border-radius:9px }
    .help{ display:none }
  }

  /* ====== 版面：橫向（左右 35% + 35%，整體 70% 寬，置中）======= */
  @media (min-aspect-ratio: 5/4) and (min-width: 900px){
    .app{
      width:100vw;
      height:calc(var(--vh)*100);
      grid-template-columns: var(--side-w) var(--side-w);
      grid-template-areas:
        "header header"
        "hold   board"
        "tray   board"
        "help   board";
      grid-template-rows: auto 1fr auto auto;
      gap:18px 24px;
      justify-content:center;  /* 讓 70% 的雙欄置中 */
      padding:14px 18px calc(14px + env(safe-area-inset-bottom));
    }
    .hold-row, .tray, .help{ width:var(--side-w); margin:0; }
    .board-wrap{ align-self:center; justify-self:center; }
    .help{ display:block; }
  }

  /* 手勢由遊戲處理，不讓瀏覽器搶去捲動/返回 */
  html,body,.app,.board-wrap,.board,.slot,.hold-slot,.piece{ touch-action:none }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand"><span class="dot"></span> Block Blast — Flow+ 版</div>

      <div class="scorebox">
        <div><div class="label">分數</div><div id="score" class="value">0</div></div>
        <div><div class="label">最高分</div><div id="best" class="value">0</div></div>
      </div>

      <div class="combo" aria-label="連擊狀態">
        <div id="comboTag" class="tag">COMBO ×1</div>
        <div class="bar"><i id="comboBar"></i></div>
      </div>

      <div class="fever"><div class="fever-label">FEVER</div><div class="fever-bar"><i id="feverFill"></i></div></div>
      <div class="stars">⭐ <b id="stars">0</b></div>

      <div class="controls">
        <button id="btn-undo" class="secondary">復原 ×3</button>
        <button id="btn-settings" class="ghost">⚙️</button>
        <button id="btn-daily" class="secondary">每日挑戰</button>
        <button id="btn-hint" class="secondary">提示</button>
        <button id="btn-tutorial" class="ghost">教學</button>
        <button id="btn-share" class="ghost">分享</button>
        <button id="btn-share-img" class="ghost">🖼️海報</button>
        <button id="btn-pass" class="ghost">🎯 Season</button>
        <button id="btn-mission" class="ghost">📜 任務</button>
        <button id="btn-new">新遊戲</button>
      </div>
    </header>

    <div class="board-wrap" id="boardWrap">
      <div id="board" class="board" aria-label="遊戲棋盤"></div>
      <div id="ghost" class="ghost-layer" aria-hidden="true"></div>
      <canvas id="fx" class="fx-layer"></canvas>
      <div class="toasts" id="toasts"></div>

      <div id="overlayGameOver" class="overlay">
        <div class="dialog">
          <h2>遊戲結束</h2>
          <p>本局分數 <b id="finalScore">0</b>。要不要再來一局？</p>
          <div style="display:flex; gap:8px; justify-content:center">
            <button id="btn-again">再玩一次</button>
            <button id="btn-close" class="secondary">關閉</button>
          </div>
        </div>
      </div>

      <div id="overlaySettings" class="overlay">
        <div class="dialog" style="text-align:left">
          <h2 style="text-align:center">設定</h2>
          <label><input type="checkbox" id="opt-audio" checked /> 啟用音效與音樂</label><br/>
          <label><input type="checkbox" id="opt-haptics" checked /> 啟用震動（行動裝置）</label><br/>
          <label><input type="checkbox" id="opt-reduce" /> 降低動態</label><br/>
          <label><input type="checkbox" id="opt-contrast" /> 高對比模式</label><br/>
          <label><input type="checkbox" id="opt-colorblind" /> 色盲友善調色</label><br/>
          <label><input type="checkbox" id="opt-hint" checked /> 閒置自動提示</label>
          <div style="margin-top:10px; display:flex; gap:8px; justify-content:center">
            <button id="btn-close-settings" class="secondary">關閉</button>
          </div>
        </div>
      </div>

      <div id="overlayPass" class="overlay">
        <div class="dialog" style="text-align:left">
          <h2 style="text-align:center">Season 1：Cosmetic Pass</h2>
          <div id="passList" style="max-height:40vh; overflow:auto"></div>
          <div style="text-align:center; margin-top:10px"><button id="btn-close-pass" class="secondary">關閉</button></div>
        </div>
      </div>

      <div id="overlayMission" class="overlay">
        <div class="dialog" style="text-align:left">
          <h2 style="text-align:center">任務</h2>
          <h3>每日</h3><div id="dailyList"></div>
          <h3>每週</h3><div id="weeklyList"></div>
          <div style="text-align:center; margin-top:10px"><button id="btn-close-mission" class="secondary">關閉</button></div>
        </div>
      </div>

      <div id="sr-live" aria-live="polite" style="position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden;"></div>
    </div>

    <div class="hold-row">
      <span class="hold-label">暫存（Hold）</span>
      <div id="holdSlot" class="hold-slot"></div>
      <div style="display:flex; gap:8px">
        <button id="btn-hammer" class="secondary" title="錘子：清除一格（花1⭐）">🔨</button>
        <button id="btn-shuffle" class="secondary" title="重抽托盤（花1⭐）">🔄</button>
        <button id="btn-hold" class="secondary" title="暫存格/取出">🧰</button>
      </div>
      <span id="dailyTag" class="label" style="margin-left:auto; display:none"></span>
    </div>

    <div id="tray" class="tray" aria-label="托盤（待放置方塊）">
      <div class="slot" data-index="0"></div>
      <div class="slot" data-index="1"></div>
      <div class="slot" data-index="2"></div>
    </div>

    <div class="help">
      <b>玩法</b>：拖曳托盤中的方塊到棋盤。填滿整列或整行會清除並加分。三個方塊都用完會再補三個。若托盤中任一方塊均無法放置，便判定失敗。<br>
      <b>操作</b>：拖曳放置；或以 <span class="kbd">1/2/3</span> 選塊、<span class="kbd">方向鍵</span> 移動、<span class="kbd">Space/Enter</span> 放置、<span class="kbd">Esc</span> 取消；<span class="kbd">U</span> 復原、<span class="kbd">N</span> 新遊戲、<span class="kbd">S</span> 設定、<span class="kbd">H</span> 熱度提示。
    </div>
  </div>

<script>
(function(){
  "use strict";

  /* ========= 參數 ========= */
  const GRID = 8;
  document.documentElement.style.setProperty('--grid-size', String(GRID));

  /* ========= 小工具 ========= */
  const $ = sel => document.querySelector(sel);
  const $all = sel => Array.from(document.querySelectorAll(sel));
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const px = v => Math.round(v) + "px";
  const isCoarse = window.matchMedia && window.matchMedia("(pointer:coarse)").matches;
  const buzz = pat => { if(!state.settings.haptics) return; try{ navigator.vibrate && navigator.vibrate(pat); }catch{} };
  function commasep(n){ return (n||0).toLocaleString('zh-Hant'); }
  function announce(msg){ const el=$("#sr-live"); if(!el) return; el.textContent=""; setTimeout(()=> el.textContent=msg, 10); }
  const toastHost = $("#toasts");
  function toast(text,color="#fff"){ const el=document.createElement("div"); el.className="toast"; el.textContent=text; el.style.left="50%"; el.style.top="12%"; el.style.color=color; toastHost.appendChild(el); setTimeout(()=> el.remove(), 900); }
  function showToastAt(x,y,text,color="#fff"){ const el=document.createElement("div"); el.className="toast"; el.textContent=text; el.style.left=`${x}px`; el.style.top=`${y}px`; el.style.color=color; toastHost.appendChild(el); setTimeout(()=> el.remove(), 900); }
  const rafBatch = (fn=>{ let p=0; return ()=>{ if(p) return; p=requestAnimationFrame(()=>{ p=0; try{ fn(); }catch{} }); }; });

  /* ========= 亂數（含每日種子） ========= */
  function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
  const RNG = { next: Math.random, useSystem(){ this.next=Math.random; }, useSeed(seed){ this.next = mulberry32(seed|0); } };

  /* ========= 星星沿 FEVER 條飛入 + 流光依比例 ========= */
  function flyStarsToFever(count, fromRect){
    const bar=$(".fever-bar"); const fill=$("#feverFill"); if(!bar||count<=0) return;
    const br=bar.getBoundingClientRect(); const fr=fill? fill.getBoundingClientRect() : {left:br.left,width:0};
    const yCenter = br.top + br.height/2;
    const endX = (fr.width>0 ? fr.left + fr.width - 8 : br.left + 6);

    const reduce = state.settings.reduce;
    const tApproach = reduce ? 160 : 360;
    const tSlide    = reduce ? 100 : 200;
    const tConverge = reduce ? 140 : 240;

    for(let i=0;i<count;i++){
      const star=document.createElement("div");
      star.className="star-fly"; star.textContent="⭐";
      document.body.appendChild(star);

      const sx = fromRect ? (fromRect.left + fromRect.width/2) : (window.innerWidth/2);
      const sy = fromRect ? (fromRect.top  + fromRect.height/2) : (window.innerHeight/2);
      const start={ x: sx + (Math.random()*40-20), y: sy + (Math.random()*30-15) };

      const entryX = (fr.width>0)
        ? fr.left + Math.max(12, Math.min(fr.width-26, fr.width*(0.15+0.4*Math.random())))
        : br.left + 14;
      const slideToX = Math.min(endX-10, entryX + Math.max(30, (fr.width||80)*0.35));

      const ctrl ={ x: (start.x+entryX)/2 + (Math.random()*60-30),
                    y: Math.min(start.y, br.top-40) - Math.random()*60 };

      animateBezier(star, start, ctrl, {x:entryX, y:yCenter}, tApproach, ()=>{
        animateLinear(star, {x:entryX, y:yCenter}, {x:slideToX, y:yCenter}, tSlide, ()=>{
          animateBezier(star, {x:slideToX, y:yCenter},
                             {x: (slideToX+endX)/2 + 10, y: yCenter - 14},
                             {x:endX, y:yCenter}, tConverge, ()=>{
            star.remove(); pingFeverBar(); sweepFeverBar();
          }, true);
        });
      });
    }
  }
  function animateBezier(el, p0, p1, p2, dur, done, fadeOut=false){
    const t0 = performance.now();
    (function step(now){
      const t = Math.min(1, (now - t0)/dur);
      const e = 1 - Math.pow(1-t, 3);
      const x = (1-e)*(1-e)*p0.x + 2*(1-e)*e*p1.x + e*e*p2.x;
      const y = (1-e)*(1-e)*p0.y + 2*(1-e)*e*p1.y + e*e*p2.y;
      const s = 0.7 + 0.5*e;
      el.style.transform = `translate(${x}px, ${y}px) scale(${s})`;
      el.style.opacity = fadeOut ? String(1 - 0.6*e) : "1";
      if(t<1) requestAnimationFrame(step); else{ done && done(); }
    })(t0);
  }
  function animateLinear(el, p0, p1, dur, done){
    const t0 = performance.now();
    (function step(now){
      const t = Math.min(1, (now - t0)/dur);
      const e = t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
      const x = p0.x + (p1.x - p0.x)*e;
      const y = p0.y + (p1.y - p0.y)*e;
      el.style.transform = `translate(${x}px, ${y}px) scale(1)`;
      if(t<1) requestAnimationFrame(step); else{ done && done(); }
    })(t0);
  }
  function pingFeverBar(){
    const i=$("#feverFill"); if(!i) return;
    i.style.transition='transform .18s ease'; i.style.transform='scaleX(var(--fever)) translateZ(0)'; // 保留 transform
    setTimeout(()=>{ i.style.transition=''; }, 180);
  }
  function sweepFeverBar(){
    const bar=$(".fever-bar"); const fill=$("#feverFill"); if(!bar) return;
    const br=bar.getBoundingClientRect(); const fr=fill ? fill.getBoundingClientRect() : {width:0,left:br.left};
    const s=document.createElement("div"); s.className="fever-sweep";
    const w = br.width * 0.22; s.style.width = w + "px"; s.style.left = (-w) + "px"; bar.appendChild(s);
    const travel = Math.max(0, fr.width); const dur = state.settings.reduce ? 220 : 350;
    s.animate([{ transform:'translateX(0)' }, { transform:`translateX(${travel}px)` }], { duration:dur, easing:'linear' }).onfinish = ()=> s.remove();
  }

  /* ========= 棋盤/狀態 ========= */
  const SIZE = GRID;
  const STORAGE_KEY   = "blockblast_state_v26_full";
  const SETTINGS_KEY  = "blockblast_settings_v4";
  const MISSIONS_KEY  = "blockblast_missions_v1";
  const BEST_KEY      = "blockblast_best";
  const PALETTE_DEFAULT = ["#7aa2ff","#6ee7b7","#f472b6","#fbbf24","#34d399","#a78bfa","#f87171","#60a5fa","#22d3ee","#f59e0b"];
  const PALETTE_CVD     = ["#000000","#E69F00","#56B4E9","#009E73","#F0E442","#0072B2","#D55E00","#CC79A7"];

  function shape(pattern){
    let coords=[];
    for(let y=0;y<pattern.length;y++){
      const row=pattern[y];
      for(let x=0;x<row.length;x++) if(row[x]!==' ') coords.push([x,y]);
    }
    const minX=Math.min(...coords.map(c=>c[0]));
    const minY=Math.min(...coords.map(c=>c[1]));
    coords=coords.map(([x,y])=>[x-minX,y-minY]);
    const w=Math.max(...coords.map(c=>c[0]))+1;
    const h=Math.max(...coords.map(c=>c[1]))+1;
    return { cells:coords, w, h, n:coords.length };
  }
  const SHAPES = [
    shape(["X"]),
    shape(["XX"]),shape(["XXX"]),shape(["XXXX"]),shape(["XXXXX"]),
    shape(["X","X"]),shape(["X","X","X"]),shape(["X","X","X","X"]),shape(["X","X","X","X","X"]),
    shape(["XX","XX"]),
    shape(["X ","XX"]), shape([" X","XX"]),
    shape(["X  ","XXX"]), shape(["  X","XXX"]),
    shape(["X ","X ","XX"]), shape([" X"," X","XX"]),
    shape(["XX "," XX"]), shape([" XX","XX "]),
    shape(["XXX"," X "]),
    shape(["X X","XXX"]),
    shape([" X ","XXX"," X "]),
  ];

  function emptyBoard(){ return Array.from({length:SIZE}, ()=> Array(SIZE).fill(null)); }

  const state = {
    board: emptyBoard(), score:0, best:Number(localStorage.getItem(BEST_KEY)||0),
    tray:[null,null,null], usedThisSet:0, history:[], gameOver:false,
    streak:0, lastActionAt:Date.now(),
    fever:{ meter:0, active:false, until:0 },
    settings: loadSettings(),
    undoCharges: 3, stars: 0, hold: null,
    mode:"classic",
    tools:{ hammer:false },
    hintShown:false, awaitingHold:false,
    stats:{ placed:0, lines:0, sessionScore:0, feverTriggers:0, starsGain:0, hammer:0, games:0, maxCombo:0 },
    tutorial:{ active:false, busy:false, timer:null }
  };

  function loadSettings(){
    const def={ audio:true, haptics:true, reduce: window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches, contrast:false, colorblind:false, hint:true };
    try{ const raw=localStorage.getItem(SETTINGS_KEY); if(!raw) return def; return {...def, ...JSON.parse(raw)}; }catch(e){ return def; }
  }
  function saveSettings(){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(state.settings)); }
  function currentPalette(){ return state.settings.colorblind ? PALETTE_CVD : PALETTE_DEFAULT; }

  /* ========= 持久化 ========= */
  function saveState(){
    const data={
      board:state.board, tray:state.tray, usedThisSet:state.usedThisSet,
      score:state.score, best:state.best, stars:state.stars,
      hold:state.hold, fever:state.fever, undoCharges:state.undoCharges,
      mode:state.mode, stats:state.stats
    };
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }catch(e){}
  }
  function loadState(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY);
      if(!raw) return false;
      const data=JSON.parse(raw);
      state.board = (data.board && Array.isArray(data.board) && data.board.length===SIZE) ? data.board : emptyBoard();
      state.tray  = Array.isArray(data.tray) ? data.tray.map(p=> (p && p.cells && p.w) ? p : null) : [null,null,null];
      state.usedThisSet = data.usedThisSet||0;
      state.score=data.score||0;
      state.best = (typeof data.best==='number') ? data.best : state.best;
      state.stars=data.stars||0;
      state.hold = data.hold||null;
      state.fever= data.fever||{meter:0,active:false,until:0};
      state.undoCharges = data.undoCharges ?? 3;
      state.mode = data.mode||'classic';
      state.stats = data.stats||state.stats;
      localStorage.setItem(BEST_KEY, String(state.best||0));
      return true;
    }catch(e){ console.warn('loadState failed', e); return false; }
  }

  /* === 形狀配重 === */
  function freeRatio(){ let free=0; for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(!state.board[y][x]) free++; return free/(SIZE*SIZE); }
  function chooseWeightedShape(){
    const f = freeRatio();
    const weights = SHAPES.map(s=>{
      let w = 1.0;
      if(s.n<=2) w *= 1.6; else if(s.n===3) w *= 1.3; else if(s.n===4) w *= 1.05; else if(s.n>=5) w *= 0.85;
      if(s.w===2 && s.h===2 && s.n===4) w *= 1.5;
      if((s.w===5&&s.h===1)||(s.w===1&&s.h===5)) w *= 0.65;
      if(f < 0.35){ if(s.n<=3) w*=1.6; if(s.n>=5) w*=0.65; }
      else if(f > 0.70){ if(s.n>=4) w*=1.20; }
      return w;
    });
    const total = weights.reduce((a,b)=>a+b,0);
    let r = RNG.next()*total; let idx=0;
    for(let i=0;i<weights.length;i++){ r-=weights[i]; if(r<=0){ idx=i; break; } }
    return SHAPES[idx];
  }
  function pickPiece(){
    const base = chooseWeightedShape();
    const color = currentPalette()[Math.floor(RNG.next()*currentPalette().length)];
    return { cells:base.cells.map(([x,y])=>[x,y]), w:base.w, h:base.h, n:base.n, color, id:Math.random().toString(36).slice(2,9) };
  }

  /* ========= 建盤 & DOM ========= */
  const boardEl=$("#board"), ghostEl=$("#ghost"), boardWrap=$("#boardWrap"), fxCanvas=$("#fx");
  const scoreEl=$("#score"), bestEl=$("#best"), starsEl=$("#stars");
  const comboTag=$("#comboTag"), comboBar=$("#comboBar"), feverFill=$("#feverFill");

  function buildBoardUI(){
    boardEl.innerHTML="";
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const cell=document.createElement("div");
        cell.className="cell"; cell.dataset.x=x; cell.dataset.y=y;
        const tile=document.createElement("div"); tile.className="tile"; tile.hidden=true;
        cell.appendChild(tile); boardEl.appendChild(cell);
      }
    }
  }
  function cellAt(x,y){ return boardEl.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`); }
  buildBoardUI();

  function renderHUD(){
    scoreEl.textContent=commasep(state.score); bestEl.textContent=commasep(state.best);
    $("#btn-undo").textContent=`復原 ×${state.undoCharges}`;
    starsEl.textContent = state.stars;
    $("#dailyTag").style.display = (state.mode==='daily')?'inline':'none';
    $("#dailyTag").textContent = state.mode==='daily' ? '每日挑戰中' : '';
    $("#btn-tutorial").textContent = state.tutorial.active ? "退出教學" : "教學";
    $("#btn-tutorial").classList.toggle("secondary", state.tutorial.active);
    if(feverFill){ feverFill.style.setProperty('--fever', state.fever.meter/100); }
  }
  function renderBoard(){
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
      const tile=cellAt(x,y).firstElementChild; const c=state.board[y][x];
      if(c){ tile.hidden=false; tile.style.background=c; }
      else{ tile.hidden=true; tile.style.background="transparent"; tile.classList.remove("clearing","appear"); tile.style.removeProperty("--delay"); tile.removeAttribute("data-delay"); }
    }
    document.body.classList.toggle("high-contrast", !!state.settings.contrast);
    renderHUD();
  }

  /* === 候選渲染 + 縮放置中 === */
  function renderPieceInto(slotEl, p){
    slotEl.innerHTML=""; if(!p){ slotEl.classList.add("empty"); return; } slotEl.classList.remove("empty");
    const wrap=document.createElement("div"); wrap.className="pwrap";
    const inner=document.createElement("div"); inner.className="pinner";
    const pieceEl=document.createElement("div"); pieceEl.className="piece";
    pieceEl.style.gridTemplateColumns=`repeat(${p.w}, var(--tray-cell))`;
    pieceEl.style.gridTemplateRows=`repeat(${p.h}, var(--tray-cell))`;
    p.cells.forEach(([x,y])=>{
      const c=document.createElement("div"); c.className="cell-mini"; c.style.background=p.color;
      c.style.gridColumnStart=x+1; c.style.gridRowStart=y+1; pieceEl.appendChild(c);
    });
    inner.appendChild(pieceEl); wrap.appendChild(inner); slotEl.appendChild(wrap);
    fitPieceIntoSlot(pieceEl, slotEl, p.w, p.h);

    slotEl.onpointerenter = ()=> slotEl.classList.add('hover-mag');
    slotEl.onpointerleave = ()=> slotEl.classList.remove('hover-mag');
    slotEl.onpointerdown  = ()=>{ slotEl.classList.add('hover-mag'); setTimeout(()=> slotEl.classList.remove('hover-mag'), 180); };
    return pieceEl;
  }
  function renderHold(){
    const slot=$("#holdSlot"); slot.innerHTML="";
    if(!state.hold){ slot.textContent="（空）"; return; }
    const p=state.hold;
    const wrap=document.createElement("div"); wrap.className="pwrap";
    const inner=document.createElement("div"); inner.className="pinner";
    const el=document.createElement("div"); el.className="piece";
    el.style.gridTemplateColumns=`repeat(${p.w}, var(--tray-cell))`;
    el.style.gridTemplateRows=`repeat(${p.h}, var(--tray-cell))`;
    p.cells.forEach(([x,y])=>{ const c=document.createElement("div"); c.className="cell-mini"; c.style.background=p.color; c.style.gridColumnStart=x+1; c.style.gridRowStart=y+1; el.appendChild(c); });
    inner.appendChild(el); wrap.appendChild(inner); slot.appendChild(wrap);
    fitPieceIntoSlot(el, slot, p.w, p.h);
  }
  function renderTray(){
    $all(".slot").forEach(slot=>{ slot.innerHTML=""; slot.classList.add("empty"); slot.classList.remove("hint","hover-mag"); });
    state.tray.forEach((p, idx)=>{
      const slot=document.querySelector(`.slot[data-index="${idx}"]`);
      if(!p){ slot.classList.add("empty"); return; }
      const pieceEl=renderPieceInto(slot,p);
      pieceEl.dataset.index=idx;
      pieceEl.addEventListener("pointerdown", onPiecePointerDown, {passive:false});
    });
    renderHold();
    requestAnimationFrame(fitTrayPieces);
  }

  /* ========= 候選縮放置中 ========= */
  function fitPieceIntoSlot(pieceEl, slot, cols, rows){
    const rootCS = getComputedStyle(document.documentElement);
    const trayCell = parseFloat(rootCS.getPropertyValue('--tray-cell')) || 30;
    const fillBase = parseFloat(rootCS.getPropertyValue('--tray-fill')) || 0.94;
    const maxS     = parseFloat(rootCS.getPropertyValue('--tray-scale-max')) || 1.8;

    const gap = parseFloat(getComputedStyle(pieceEl).gap) || 4;
    const naturalW = cols*trayCell + (cols-1)*gap;
    const naturalH = rows*trayCell + (rows-1)*gap;

    const scs = getComputedStyle(slot);
    const availW = slot.clientWidth  - (parseFloat(scs.paddingLeft)||0) - (parseFloat(scs.paddingRight)||0);
    const availH = slot.clientHeight - (parseFloat(scs.paddingTop )||0) - (parseFloat(scs.paddingBottom)||0);

    const longness = Math.max(cols, rows);
    const fill = (longness>=4) ? fillBase*0.92 : fillBase;

    const sRaw = Math.min(availW/naturalW, availH/naturalH) * fill;
    const s    = Math.min(maxS, sRaw);

    pieceEl.style.transform = `scale(${s})`;
    pieceEl.style.transformOrigin = 'center center';
    pieceEl.dataset.scale = String(s);
    pieceEl.dataset.cols  = String(cols);
    pieceEl.dataset.rows  = String(rows);
  }
  function fitTrayPieces(){
    $all(".slot .piece").forEach(el=>{
      const slot = el.closest('.slot');
      const cols = Number(el.dataset.cols) || parseInt((el.style.gridTemplateColumns.match(/repeat\((\d+)/)||[])[1]||'1',10);
      const rows = Number(el.dataset.rows) || parseInt((el.style.gridTemplateRows.match(/repeat\((\d+)/)||[])[1]||'1',10);
      fitPieceIntoSlot(el, slot, cols, rows);
    });
    const hold = $("#holdSlot .piece");
    if(hold){
      const cols = Number(hold.dataset.cols) || parseInt((hold.style.gridTemplateColumns.match(/repeat\((\d+)/)||[])[1]||'1',10);
      const rows = Number(hold.dataset.rows) || parseInt((hold.style.gridTemplateRows.match(/repeat\((\d+)/)||[])[1]||'1',10);
      fitPieceIntoSlot(hold, $("#holdSlot"), cols, rows);
    }
  }

  /* ========= 版面凍結 / 幽靈層同步 ========= */
  let layoutFreeze=false;
  function freezeLayout(){ layoutFreeze=true; }
  function unfreezeLayout(){ layoutFreeze=false; fitLayout(); }
  function ensureOverlaySync(){
    const pad=parseFloat(getComputedStyle(boardEl).paddingLeft)||0;
    const b=boardEl.getBoundingClientRect();
    const w=boardWrap.getBoundingClientRect();
    const L=Math.round(b.left - w.left + pad);
    const T=Math.round(b.top  - w.top  + pad);
    const W=Math.round(b.width  - pad*2);
    const H=Math.round(b.height - pad*2);
    const need = (Math.abs((parseFloat(ghostEl.style.left||0)) - L) > 1) ||
                 (Math.abs((parseFloat(ghostEl.style.top ||0)) - T) > 1) ||
                 (Math.abs((parseFloat(ghostEl.style.width||0)) - W) > 1) ||
                 (Math.abs((parseFloat(ghostEl.style.height||0)) - H) > 1);
    if(need){
      ghostEl.style.left=px(L); ghostEl.style.top=px(T);
      ghostEl.style.width=px(W); ghostEl.style.height=px(H);
      fxCanvas.style.left=px(L); fxCanvas.style.top=px(T); fxCanvas.style.width=px(W); fxCanvas.style.height=px(H);
      const dpr=Math.min(2, window.devicePixelRatio||1);
      fxCanvas.width  = Math.round(W * dpr);
      fxCanvas.height = Math.round(H * dpr);
    }
  }
  const ro = new ResizeObserver(()=> rafBatch(ensureOverlaySync));
  ro.observe(boardEl);

  /* ========= 近距離自動吸附 ========= */
  function nearestCellFromPoint(clientX, clientY){
    const c00 = cellAt(0,0).getBoundingClientRect();
    const c10 = cellAt(1,0).getBoundingClientRect();
    const c01 = cellAt(0,1).getBoundingClientRect();
    const stepX = (SIZE>1) ? (c10.left - c00.left) : c00.width;
    const stepY = (SIZE>1) ? (c01.top  - c00.top ) : c00.height;
    const boardRect = boardEl.getBoundingClientRect();
    const magnet = isCoarse ? Math.max(c00.width * 0.75, 26) : Math.max(c00.width * 0.5, 18);
    if(clientX < boardRect.left - magnet || clientX > boardRect.right + magnet ||
       clientY < boardRect.top  - magnet || clientY > boardRect.bottom + magnet){
      return {gx:-1, gy:-1};
    }
    const gx = Math.round((clientX - c00.left)/stepX);
    const gy = Math.round((clientY - c00.top )/stepY);
    if(gx<0||gy<0||gx>=SIZE||gy>=SIZE) return {gx:-1, gy:-1};
    return {gx,gy};
  }

  /* ========= 拖曳 & 幽靈（RAF + Hysteresis + 高亮） ========= */
  // === Highlight
  let highlightCell=null;
  function clearHighlight(){
    if(highlightCell){ try{ cellAt(highlightCell.x,highlightCell.y).classList.remove('highlight'); }catch{} }
    highlightCell=null;
  }
  function setHighlight(x,y){
    if(highlightCell && (highlightCell.x!==x || highlightCell.y!==y)){
      cellAt(highlightCell.x,highlightCell.y)?.classList.remove('highlight');
    }
    const c=cellAt(x,y); if(c){ c.classList.add('highlight'); highlightCell={x,y}; }
  }

  let drag=null, dragRAF=0, lastMoveEvent=null;
  function clearGhost(){ ghostEl.innerHTML=""; }

  function computeGrabOffset(e, pieceEl, piece){
    const rect = pieceEl.getBoundingClientRect();
    const cell = pieceEl.querySelector('.cell-mini');
    const cs = cell ? cell.getBoundingClientRect().width : 24;
    const gap = Math.max(0, (pieceEl.children.length>1)
      ? (()=>{ const a = pieceEl.querySelector('.cell-mini');
               const b = [...pieceEl.querySelectorAll('.cell-mini')].find(n=>n!==a && n.getBoundingClientRect().top===a.getBoundingClientRect().top);
               if(!a || !b) return (parseFloat(getComputedStyle(pieceEl).gap)||4) * (parseFloat(pieceEl.dataset.scale)||1);
               return Math.max(0, b.getBoundingClientRect().left - a.getBoundingClientRect().right);
             })()
      : (parseFloat(getComputedStyle(pieceEl).gap)||4) * (parseFloat(pieceEl.dataset.scale)||1) );
    const lx=e.clientX - rect.left, ly=e.clientY - rect.top;
    let best={x:0,y:0,d:Infinity};
    for(const [x,y] of piece.cells){
      const cx = x*(cs+gap) + cs/2;
      const cy = y*(cs+gap) + cs/2;
      const d  = (lx-cx)*(lx-cx) + (ly-cy)*(ly-cy);
      if(d < best.d) best = {x,y,d};
    }
    return { sx:best.x, sy:best.y };
  }
  function makeProxy(fromEl, grab, piece){
    const proxy = fromEl.cloneNode(true);
    proxy.className="drag-proxy";
    document.body.appendChild(proxy);

    const rootCS = getComputedStyle(document.documentElement);
    const trayCell = parseFloat(rootCS.getPropertyValue('--tray-cell')) || 30;
    const gap = parseFloat(getComputedStyle(fromEl).gap) || 4;
    const naturalW = piece.w*trayCell + (piece.w-1)*gap;
    const bboxW = fromEl.getBoundingClientRect().width;
    const scale = parseFloat(fromEl.dataset.scale) || (bboxW / naturalW);

    const offX = (grab.sx * (trayCell + gap) + trayCell/2) * scale;
    const offY = (grab.sy * (trayCell + gap) + trayCell/2) * scale;

    proxy.dataset.offX = offX;
    proxy.dataset.offY = offY;
    proxy.dataset.scale = scale;
    return proxy;
  }
  function moveProxy(x,y){
    if(!drag) return;
    const offX=parseFloat(drag.proxyEl.dataset.offX)||20;
    const offY=parseFloat(drag.proxyEl.dataset.offY)||20;
    const sc  =parseFloat(drag.proxyEl.dataset.scale)||1;
    const lift = isCoarse ? 14 : 6; // 手機把代理稍微抬高
    drag.proxyEl.style.transform = `translate(${Math.round(x-offX)}px, ${Math.round(y-offY-lift)}px) scale(${sc})`;
  }

  // === RAF drag
  function onPiecePointerDown(e){
    if(state.gameOver) return;
    if(state.tutorial.active) return;
    const idx = Number(e.currentTarget.dataset.index);

    if(state.awaitingHold){
      const tmp = state.hold;
      state.hold = state.tray[idx];
      state.tray[idx] = tmp || null;
      state.awaitingHold = false;
      renderTray(); saveState(); buzz(12);
      return;
    }

    freezeLayout(); clearHint();
    const piece = state.tray[idx]; if(!piece) return;

    const grab = computeGrabOffset(e, e.currentTarget, piece);
    e.currentTarget.setPointerCapture(e.pointerId);
    e.currentTarget.classList.add("grabbed");

    const proxy = makeProxy(e.currentTarget, grab, piece);
    drag={ piece, idx, proxyEl:proxy, grab, grid:buildGridMetrics(), lastOk:null, ghostNodes:null, anchor:null };
    moveProxy(e.clientX,e.clientY);

    window.addEventListener("pointermove", onDragMove, {passive:false});
    window.addEventListener("pointerup", onDragEnd, {once:true});
    window.addEventListener("pointercancel", onDragCancel, {once:true});

    if(!dragRAF) dragRAF=requestAnimationFrame(dragTick);
    lastMoveEvent=e;

    updateGhost(e.clientX,e.clientY);
  }
  function onDragMove(e){
    e.preventDefault();
    const list = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
    lastMoveEvent = list[list.length - 1];
  }
  function dragTick(){
    if(drag && lastMoveEvent){
      const { clientX, clientY } = lastMoveEvent;
      moveProxy(clientX, clientY);
      updateGhost(clientX, clientY);
      lastMoveEvent = null;
    }
    if(drag) dragRAF = requestAnimationFrame(dragTick);
    else{ cancelAnimationFrame(dragRAF); dragRAF = 0; }
  }
  function onDragEnd(e){
    if(!drag) return;
    const {piece, idx, anchor}=drag;
    $all(`.piece[data-index="${idx}"]`).forEach(el=>{ try{ el.releasePointerCapture(e.pointerId); }catch(_){} el.classList.remove("grabbed"); });
    if(anchor && anchor.ok){ commitPlacement(piece, idx, anchor.x, anchor.y); buzz(10); }
    else{ buzz(12); }
    try{ drag.proxyEl.remove(); }catch(_){}
    drag=null; clearGhost(); clearHighlight();
    window.removeEventListener("pointermove", onDragMove);
    unfreezeLayout();
  }
  function onDragCancel(){
    if(!drag) return;
    try{ drag.proxyEl.remove(); }catch(_){}
    drag=null; clearGhost(); clearHighlight();
    window.removeEventListener("pointermove", onDragMove);
    unfreezeLayout();
  }

  function buildGridMetrics(){
    const r00 = cellAt(0,0).getBoundingClientRect();
    const r10 = cellAt(1,0).getBoundingClientRect();
    const r01 = cellAt(0,1).getBoundingClientRect();
    const rect = boardEl.getBoundingClientRect();
    const pad = parseFloat(getComputedStyle(boardEl).paddingLeft)||0;
    return {
      left: r00.left, top: r00.top,
      stepX: (SIZE>1 ? r10.left - r00.left : r00.width),
      stepY: (SIZE>1 ? r01.top  - r00.top  : r00.height),
      boardRect: rect, pad
    };
  }
  function cellIndexFromPoint(clientX,clientY){
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const r=cellAt(x,y).getBoundingClientRect();
        if(clientX>=r.left && clientX<r.right && clientY>=r.top && clientY<r.bottom) return {gx:x, gy:y};
      }
    }
    return {gx:-1, gy:-1};
  }
  function cellRectRel(x,y){
    if(x<0||y<0||x>=SIZE||y>=SIZE) return null;
    const r=cellAt(x,y).getBoundingClientRect();
    const rect=boardEl.getBoundingClientRect();
    const pad=parseFloat(getComputedStyle(boardEl).paddingLeft)||0;
    return { left:r.left-rect.left-pad, top:r.top-rect.top-pad, width:r.width, height:r.height };
  }

  function updateGhost(clientX,clientY){
    ensureOverlaySync(); clearGhost();
    let {gx,gy}=cellIndexFromPoint(clientX,clientY);
    if(gx<0||gy<0){ const n=nearestCellFromPoint(clientX,clientY); gx=n.gx; gy=n.gy; }
    if(gx<0||gy<0){ drag.anchor=null; clearHighlight(); return; }

    const sx=(drag && drag.grab)?drag.grab.sx:0;
    const sy=(drag && drag.grab)?drag.grab.sy:0;
    let ax=gx-sx, ay=gy-sy;
    const piece=drag.piece;
    let ok = canPlace(piece, ax, ay);

    // Hysteresis：若新位置無效且離上次有效錨點很近，維持舊錨
    if(!ok && drag.lastOk){
      const dx = gx - (drag.lastOk.x + sx);
      const dy = gy - (drag.lastOk.y + sy);
      const near = Math.hypot(dx, dy) < 0.35; // < 0.35 格
      if(near){ ax = drag.lastOk.x; ay = drag.lastOk.y; ok = true; }
    }

    // 重用 ghost node
    if(!drag.ghostNodes || drag.ghostNodes.length !== drag.piece.cells.length){
      ghostEl.innerHTML="";
      drag.ghostNodes = drag.piece.cells.map(()=>{ const d=document.createElement("div"); d.className="ghost-cell"; ghostEl.appendChild(d); return d; });
    }
    drag.ghostNodes.forEach((node,i)=>{
      const [dx,dy] = drag.piece.cells[i];
      const rr = cellRectRel(ax+dx, ay+dy);
      if(!rr) return;
      node.style.left=px(rr.left); node.style.top=px(rr.top);
      node.style.width=px(rr.width); node.style.height=px(rr.height);
      node.className = 'ghost-cell ' + (ok ? '' : 'ghost-invalid');
    });

    drag.anchor={x:ax, y:ay, ok};
    if(ok){ drag.lastOk = {x:ax, y:ay}; setHighlight(ax+sx, ay+sy); } else { clearHighlight(); }
  }

  /* ========= 計分 / 清行 / FEVER ========= */
  const FEVER_PER_LINE = Math.round(100 / Math.max(3, Math.round(SIZE/2)));
  function addScore(delta){
    state.score += delta;
    if(state.score > state.best){ state.best = state.score; localStorage.setItem(BEST_KEY, String(state.best)); }
    renderHUD(); announce(`分數 ${state.score}，最高分 ${state.best}`);
  }
  function addStars(n){ state.stars = Math.min(99, state.stars + n); renderHUD(); missionsAddProgress('stars', n); }
  function spendStars(n){ if(state.stars < n){ toast("⭐ 不足","#ffd1d1"); return false; } state.stars -= n; renderHUD(); return true; }

  function findFullLines(){
    const rows=[], cols=[];
    for(let y=0;y<SIZE;y++) if(state.board[y].every(Boolean)) rows.push(y);
    for(let x=0;x<SIZE;x++){ let full=true; for(let y=0;y<SIZE;y++){ if(!state.board[y][x]){ full=false; break; } } if(full) cols.push(x); }
    return { rows, cols };
  }

  function awardFeverStars(linesCleared){
    if(!state.fever.active || !linesCleared) return 0;
    const base = 0.22;
    const comboBonus = Math.min(0.25, state.streak*0.05);
    const multiBonus = Math.min(0.15, Math.max(0, linesCleared-1)*0.08);
    const p = Math.min(0.65, base + comboBonus + multiBonus);

    let stars = 0;
    for(let i=0;i<linesCleared;i++){ if(RNG.next() < p) stars++; }
    if(stars>0){ addStars(stars); flyStarsToFever(stars, boardEl.getBoundingClientRect()); buzz([8,40,8]); }
    return stars;
  }

  function animateAndClear(rows, cols){
    freezeLayout();
    const toClear=[]; const cx=(SIZE-1)/2, cy=(SIZE-1)/2; const delayUnit=16;
    rows.forEach(y=>{ for(let x=0;x<SIZE;x++){ const d=Math.abs(x-cx)*delayUnit; const tile=cellAt(x,y).firstElementChild; tile.classList.add("clearing"); tile.style.setProperty("--delay",`${d}ms`); tile.setAttribute("data-delay",""); toClear.push([x,y,d]); }});
    cols.forEach(x=>{ for(let y=0;y<SIZE;y++){ const d=Math.abs(y-cy)*delayUnit; const tile=cellAt(x,y).firstElementChild; tile.classList.add("clearing"); tile.style.setProperty("--delay",`${d}ms`); tile.setAttribute("data-delay",""); toClear.push([x,y,d]); }});
    const maxDelay = toClear.reduce((m,c)=>Math.max(m,c[2]),0);
    setTimeout(()=>{ toClear.forEach(([x,y])=> state.board[y][x]=null); renderBoard(); saveState(); unfreezeLayout(); }, maxDelay+240);
  }

  let comboTimer=null, comboTimeMs=3400;
  function showCombo(){
    if(state.streak<=0){ comboTag.classList.remove("show"); comboBar.style.width="0%"; return; }
    comboTag.classList.add("show"); comboTag.textContent=`COMBO ×${state.streak}`;
    comboTag.style.transform="scale(1)"; requestAnimationFrame(()=> comboTag.style.transform="scale(1.06)");
    music.setComboLevel(state.streak);
  }
  function startComboTimer(){
    const start=Date.now();
    if(comboTimer) clearInterval(comboTimer);
    comboTimer=setInterval(()=>{
      const p=clamp((Date.now()-start)/comboTimeMs,0,1);
      comboBar.style.width=`${(1-p)*100}%`;
      if(p>=1){ resetCombo(); }
    },100);
  }
  function resetCombo(){
    state.streak=0; comboBar.style.width="0%"; comboTag.classList.remove("show"); music.setComboLevel(0);
    if(comboTimer) clearInterval(comboTimer), comboTimer=null;
  }

  function setFeverMeter(v){ state.fever.meter=Math.max(0,Math.min(100,v)); if(feverFill) feverFill.style.setProperty('--fever', state.fever.meter/100); saveState(); }
  function triggerFever(durationMs=14000){
    if(state.fever.active) return;
    state.fever.active=true; state.fever.until=Date.now()+durationMs; document.body.classList.add("is-fever");
    const b=boardEl.getBoundingClientRect(), w=boardWrap.getBoundingClientRect();
    showToastAt((b.left-w.left)+boardEl.clientWidth/2, 24, "FEVER ×2!", "#ffd08a");
    state.stats.feverTriggers++; missionsAddProgress('fever',1);
    music.setFever(true);
    requestAnimationFrame(function tick(){ if(!state.fever.active) return; if(Date.now()>=state.fever.until){ state.fever.active=false; document.body.classList.remove("is-fever"); setFeverMeter(0); music.setFever(false);} else requestAnimationFrame(tick); });
  }

  function snapshotForUndo(){
    return { board: JSON.parse(JSON.stringify(state.board)), score:state.score, tray: JSON.parse(JSON.stringify(state.tray)), usedThisSet:state.usedThisSet, streak:state.streak, hold:state.hold?JSON.parse(JSON.stringify(state.hold)):null, fever: JSON.parse(JSON.stringify(state.fever)), stats: JSON.parse(JSON.stringify(state.stats)) };
  }

  function commitPlacement(piece, trayIdx, x, y){
    clearGhost(); clearHighlight(); clearHint();
    const prev = snapshotForUndo();

    piece.cells.forEach(([dx,dy])=>{ state.board[y+dy][x+dx] = piece.color; });
    piece.cells.forEach(([dx,dy])=>{
      const tile=cellAt(x+dx,y+dy).firstElementChild;
      tile.hidden=false; tile.style.background=piece.color;
      tile.classList.add("appear");
      setTimeout(()=>tile.classList.remove("appear"), 200);
    });

    state.tray[trayIdx]=null; state.usedThisSet++; renderTray();
    state.stats.placed += piece.n; missionsAddProgress('place', piece.n);

    let deltaScore = piece.n;
    const { rows, cols } = findFullLines();
    const linesCleared = rows.length + cols.length;
    if(linesCleared){
      animateAndClear(rows, cols);
      buzz([10,40,12]);
      state.stats.lines += linesCleared; missionsAddProgress('lines', linesCleared);
      deltaScore += 10*linesCleared + (linesCleared>1 ? 10*(linesCleared-1) : 0);

      if(linesCleared>=2){ addStars(linesCleared-1); flyStarsToFever(linesCleared-1, boardEl.getBoundingClientRect()); }
      awardFeverStars(linesCleared);

      setFeverMeter(state.fever.meter + linesCleared*FEVER_PER_LINE + Math.min(10, piece.n));
      if(state.fever.meter >= 100) triggerFever();
      state.streak++; state.stats.maxCombo = Math.max(state.stats.maxCombo, state.streak); missionsSetProgressMax('comboMax', state.stats.maxCombo);
      deltaScore += state.streak*2; showCombo(); startComboTimer();
    } else { resetCombo(); }

    const mult = state.fever.active ? 2 : 1;
    addScore(Math.round(deltaScore * mult));
    state.stats.sessionScore += Math.round(deltaScore * mult);
    missionsSetProgressMax('sessionScore', state.stats.sessionScore);
    missionsAddProgress('scoreSum', Math.round(deltaScore * mult));

    state.history.push(prev); if(state.history.length>50) state.history.shift();

    if(state.usedThisSet >= 3) refillTrayFair();
    if(!hasAnyValidMove()) endGame();
    else { renderBoard(); saveState(); }

    state.lastActionAt=Date.now();
  }

  /* ========= 提示 ========= */
  let hintData=null;
  function bestPlacement(){
    let best=null;
    state.tray.forEach((p,idx)=>{
      if(!p) return;
      for(let y=0;y<=SIZE-p.h;y++){
        for(let x=0;x<=SIZE-p.w;x++){
          if(!canPlace(p,x,y)) continue;
          let rows=Array(SIZE).fill(0), cols=Array(SIZE).fill(0);
          for(let yy=0;yy<SIZE;yy++) for(let xx=0;xx<SIZE;xx++) if(state.board[yy][xx]){ rows[yy]++; cols[xx]++; }
          p.cells.forEach(([dx,dy])=>{ rows[y+dy]++; cols[x+dx]++; });
          const clearCount = rows.filter(v=>v===SIZE).length + cols.filter(v=>v===SIZE).length;
          const centerBias = - (Math.abs(x - (SIZE-1)/2) + Math.abs(y - (SIZE-1)/2)) * 0.01;
          const score = clearCount*100 + p.n*0.1 + centerBias;
          if(!best || score>best.score) best={ idx, x, y, score, clearCount, p };
        }
      }
    });
    return best;
  }
  function showHint(){
    clearHint();
    const b=bestPlacement();
    if(!b){ toast("沒有可放置位置","#ffd1d1"); return; }
    document.querySelector(`.slot[data-index="${b.idx}"]`)?.classList.add("hint");
    b.p.cells.forEach(([dx,dy])=>{
      const rr = cellRectRel(b.x+dx, b.y+dy);
      if(!rr) return;
      const g=document.createElement("div");
      g.className="ghost-cell";
      g.style.left=px(rr.left); g.style.top=px(rr.top); g.style.width=px(rr.width); g.style.height=px(rr.height);
      ghostEl.appendChild(g);
    });
    hintData=b; state.hintShown=true;
  }
  function clearHint(){ $all(".slot.hint").forEach(el=>el.classList.remove("hint")); $all(".ghost-cell").forEach(el=>el.remove()); hintData=null; state.hintShown=false; }
  setInterval(()=>{ if(state.settings.hint && !state.gameOver && !drag && !state.hintShown && Date.now()-state.lastActionAt>8000){ showHint(); } }, 1000);

  /* ========= 托盤配重與抽牌 ========= */
  function hasAnyValidMoveForTray(tray){ for(const p of tray){ if(!p) continue; for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(canPlace(p,x,y)) return true; } return false; }
  function hasAnyValidMove(){ return hasAnyValidMoveForTray(state.tray); }
  function refillTrayFair(){
    let pieces=[pickPiece(),pickPiece(),pickPiece()];
    let tries=0; while(!hasAnyValidMoveForTray(pieces) && tries<30){ pieces=[pickPiece(),pickPiece(),pickPiece()]; tries++; }
    state.tray=pieces; state.usedThisSet=0; renderTray(); saveState();
    requestAnimationFrame(fitTrayPieces);
  }

  /* ========= 任務、海報、動態音樂 ========= */
  let missions=null;
  function getWeekKey(d=new Date()){ const dt=new Date(d); const onejan=new Date(dt.getFullYear(),0,1); const week=Math.ceil((((dt-onejan)/86400000)+onejan.getDay()+1)/7); return `${dt.getFullYear()}-W${week}`; }
  const DAILY_POOL=[
    {id:'d_lines10', title:'清除 10 行', metric:'lines', target:10, reward:1},
    {id:'d_lines12', title:'清除 12 行', metric:'lines', target:12, reward:2},
    {id:'d_combo3',  title:'達成 3 連擊', metric:'comboMax', target:3, reward:1},
    {id:'d_place20', title:'放置 20 塊', metric:'place', target:20, reward:1},
    {id:'d_score200',title:'單局得分 200', metric:'sessionScore', target:200, reward:2},
    {id:'d_fever1',  title:'觸發 1 次 FEVER', metric:'fever', target:1, reward:2},
    {id:'d_hammer1', title:'使用錘子 1 次', metric:'hammer', target:1, reward:1}
  ];
  const WEEKLY_DEF=[
    {id:'w_score1800', title:'累積總分 1800', metric:'scoreSum', target:1800, reward:4},
    {id:'w_lines70',   title:'清除 70 行', metric:'lines', target:70, reward:3},
    {id:'w_games5',    title:'完成 5 局', metric:'games', target:5, reward:3},
    {id:'w_stars10',   title:'獲得 10 顆星', metric:'stars', target:10, reward:2}
  ];
  function seededPick(arr,count,seed){ const r=mulberry32(seed|0); const bag=[...arr]; const out=[]; for(let i=0;i<count && bag.length;i++){ const idx=Math.floor(r()*bag.length); out.push(bag.splice(idx,1)[0]); } return out; }
  function missionsLoad(){ const raw=localStorage.getItem(MISSIONS_KEY); if(raw){ try{ missions=JSON.parse(raw); }catch{ missions=null; } } if(!missions) missions={ daily:{date:"",tasks:[]}, weekly:{week:"",tasks:[]} }; missionsEnsureFresh(); }
  function missionsEnsureFresh(){ const today=new Date().toISOString().slice(0,10); if(missions.daily.date!==today){ const seed=Number(today.replace(/-/g,'')); missions.daily={ date:today, tasks:seededPick(DAILY_POOL,3,seed).map(t=>({...t,progress:0,claimed:false})) }; } const wk=getWeekKey(); if(missions.weekly.week!==wk){ missions.weekly={ week:wk, tasks:WEEKLY_DEF.map(t=>({...t,progress:0,claimed:false})) }; } missionsSave(); }
  function missionsSave(){ localStorage.setItem(MISSIONS_KEY, JSON.stringify(missions)); }
  function missionsAddProgress(metric,delta){ ['daily','weekly'].forEach(s=>{ missions[s].tasks.forEach(t=>{ if(t.metric!==metric||t.claimed) return; t.progress=Math.min(t.target,(t.progress||0)+delta); }); }); missionsSave(); }
  function missionsSetProgressMax(metric,value){ ['daily','weekly'].forEach(s=>{ missions[s].tasks.forEach(t=>{ if(t.metric!==metric||t.claimed) return; t.progress=Math.min(t.target,Math.max(t.progress||0,value)); }); }); missionsSave(); }
  function renderMissionsUI(){
    const renderList=(host,tasks)=>{
      host.innerHTML="";
      tasks.forEach((t,i)=>{ const p=Math.round(100*(t.progress/t.target));
        const wrap=document.createElement('div');
        wrap.style.cssText="padding:10px 8px;border:1px solid #2a3568;border-radius:10px;margin:6px 0;background:#151a2f;";
        wrap.innerHTML=`<div style="display:flex;justify-content:space-between;align-items:center;gap:8px;"><div style="font-weight:800">${t.title}</div><div style="font-size:12px;color:#a3acd6">${t.progress} / ${t.target}</div></div>
          <div style="position:relative;height:10px;background:#0f1528;border:1px solid #27305b;border-radius:999px;margin:8px 0 6px"><i style="position:absolute;left:0;top:0;height:100%;width:${p}%;background:linear-gradient(90deg,#3ef0b4,#7aa2ff);border-radius:999px"></i></div>
          <div style="display:flex;justify-content:flex-end;gap:8px;"><button class="claim" ${(t.progress>=t.target && !t.claimed) ? "" : "disabled"} data-scope="${host.id==='dailyList'?'daily':'weekly'}" data-idx="${i}">領取 ⭐${t.reward}</button>${t.claimed?'<span style="color:#a3acd6;font-size:12px">已領取</span>':''}</div>`;
        host.appendChild(wrap);
      });
      host.querySelectorAll('button.claim').forEach(btn=>{
        btn.addEventListener('click', ()=>{ const scope=btn.dataset.scope; const idx=Number(btn.dataset.idx); const t=missions[scope].tasks[idx]; if(!t||t.claimed||t.progress<t.target) return; t.claimed=true; addStars(t.reward); missionsSave(); renderMissionsUI(); toast("任務獎勵已領取 ⭐","#cfe"); });
      });
    };
    renderList($("#dailyList"), missions.daily.tasks);
    renderList($("#weeklyList"), missions.weekly.tasks);
  }

  /* ========= 海報分享 ========= */
  function roundRectPath(ctx,x,y,w,h,r){ const rr=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y, x+w,y+h, rr); ctx.arcTo(x+w,y+h, x,y+h, rr); ctx.arcTo(x,y+h, x,y, rr); ctx.arcTo(x,y, x+w,y, rr); ctx.closePath(); }
  function renderPosterCanvas(){
    const W=1080,H=1350,PAD=64; const cvs=document.createElement('canvas'); cvs.width=W; cvs.height=H; const ctx=cvs.getContext('2d');
    const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0f1637'); g.addColorStop(1,'#0a0d21'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#cfe1ff'; ctx.font='700 44px system-ui,-apple-system,"PingFang TC","Noto Sans TC",sans-serif'; ctx.fillText('Block Blast — Flow+ 版', PAD, PAD+32);
    ctx.font='800 40px system-ui,-apple-system,"PingFang TC","Noto Sans TC",sans-serif'; ctx.fillStyle='#fff'; ctx.fillText(`分數 ${state.score}`, PAD, PAD+96);
    ctx.fillStyle='#a3acd6'; ctx.font='700 28px system-ui,-apple-system,"PingFang TC","Noto Sans TC",sans-serif'; ctx.fillText(`最高分 ${state.best}  |  ⭐ ${state.stars}`, PAD, PAD+136); ctx.fillText(new Date().toLocaleString(), PAD, PAD+168);
    const B=Math.min(W-PAD*2,860); const boardX=(W-B)/2; const boardY=PAD+200; roundRectPath(ctx,boardX,boardY,B,B,26); ctx.fillStyle='#0e1228'; ctx.fill(); ctx.save(); ctx.clip();
    const gap=8,pad=16,cellSize=(B-pad*2-gap*(SIZE-1))/SIZE;
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){ const cx=boardX+pad+x*(cellSize+gap), cy=boardY+pad+y*(cellSize+gap);
      roundRectPath(ctx,cx,cy,cellSize,cellSize,10); ctx.fillStyle='#141837'; ctx.fill();
      const c=state.board[y][x]; if(c){ roundRectPath(ctx,cx,cy,cellSize,cellSize,12); ctx.fillStyle=c; ctx.fill(); const gg=ctx.createLinearGradient(cx,cy,cx,cy+cellSize); gg.addColorStop(0,'rgba(255,255,255,.14)'); gg.addColorStop(1,'rgba(0,0,0,.1)'); roundRectPath(ctx,cx,cy,cellSize,cellSize,12); ctx.fillStyle=gg; ctx.fill(); }
    }
    ctx.restore();
    ctx.fillStyle='#ffd08a'; ctx.font='800 28px system-ui,-apple-system,"PingFang TC","Noto Sans TC",sans-serif'; ctx.fillText(`FEVER ${(state.fever.meter|0)}%  ·  COMBO ×${Math.max(1,state.streak)}`, PAD, boardY+B+52);
    ctx.fillStyle='#5a6aa0'; ctx.font='700 22px system-ui,-apple-system,"PingFang TC","Noto Sans TC",sans-serif'; ctx.fillText('生成自 Block Blast — Flow+ 版', PAD, H-PAD+6);
    return cvs;
  }
  async function sharePoster(){
    const cvs=renderPosterCanvas();
    return new Promise((resolve)=>{ cvs.toBlob(async blob=>{
      const file=new File([blob],'blockblast-poster.png',{type:'image/png'});
      try{
        if(navigator.canShare && navigator.canShare({files:[file]})){
          await navigator.share({ files:[file], title:'Block Blast — Flow+ 版', text:`我在 Flow+ 版拿到 ${state.score} 分！` });
        }else{
          const a=document.createElement('a'); a.href=URL.createObjectURL(file); a.download='blockblast-poster.png'; document.body.appendChild(a); a.click(); a.remove(); toast("已下載海報","#cfe");
        }
        resolve();
      }catch(e){ toast("分享已取消","#ffd08a"); resolve(); }
    },'image/png'); });
  }

  /* ========= 動態音樂 ========= */
  const music=(function(){
    let ctx, master, running=false, enabled=true;
    let hatGain,kickGain,snrGain,bassGain,padGain,padOsc1,padOsc2,padOsc3,padFilter;
    let currentStep=0,nextNoteTime=0,timer=null,fever=false,comboInternal=0;
    const baseTempo=112;
    const patterns={ hat:[[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]], kick:[[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[1,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0],[1,0,0,1,0,1,0,0,1,0,1,0,0,1,0,0],[1,0,0,1,0,1,0,0,1,0,1,0,0,1,1,0],[1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0]], snr:[[0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0]], bass:[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[1,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0],[1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,1]], };
    const mixes=[{hat:.18,kick:.62,snr:.42,bass:0.00,pad:.03},{hat:.24,kick:.68,snr:.48,bass:.22,pad:.04},{hat:.30,kick:.74,snr:.56,bass:.34,pad:.05},{hat:.36,kick:.80,snr:.64,bass:.46,pad:.06},{hat:.42,kick:.86,snr:.72,bass:.58,pad:.08}];
    const levelFromCombo=c=>(c>=7?4:c>=5?3:c>=3?2:c>=1?1:0);
    function init(){ const AC=window.AudioContext||window.webkitAudioContext; if(!AC) return; if(ctx) return; ctx=new AC(); master=ctx.createGain(); master.gain.value=0.7; master.connect(ctx.destination);
      hatGain=ctx.createGain(); kickGain=ctx.createGain(); snrGain=ctx.createGain(); bassGain=ctx.createGain(); padGain=ctx.createGain();
      [hatGain,kickGain,snrGain,bassGain,padGain].forEach(g=>{ g.gain.value=0; g.connect(master); });
      padOsc1=ctx.createOscillator(); padOsc2=ctx.createOscillator(); padOsc3=ctx.createOscillator();
      [padOsc1,padOsc2,padOsc3].forEach(o=>o.type='sine');
      padFilter=ctx.createBiquadFilter(); padFilter.type='lowpass'; padFilter.frequency.value=380;
      padOsc1.frequency.value=196; padOsc2.frequency.value=246.94; padOsc3.frequency.value=293.66;
      padOsc1.connect(padFilter); padOsc2.connect(padFilter); padOsc3.connect(padFilter); padFilter.connect(padGain);
      padOsc1.start(); padOsc2.start(); padOsc3.start();
    }
    function start(){ if(!enabled) return; init(); if(!ctx||running) return; nextNoteTime=ctx.currentTime+0.05; currentStep=0; running=true; timer=setInterval(schedule,25); }
    function stop(){ running=false; if(timer) clearInterval(timer), timer=null; }
    async function resume(){ init(); if(!ctx) return; try{ await ctx.resume(); }catch{} start(); }
    function _setEnabled(on){ enabled=on; if(on) start(); else stop(); }
    function _setFever(on){ fever=!!on; }
    function _setComboLevel(combo){ comboInternal=combo; start(); if(!ctx) return; const lvl=levelFromCombo(comboInternal); const m=mixes[lvl]; const padBoost=fever?1.15:1.0; hatGain.gain.setTargetAtTime(m.hat,ctx.currentTime,.05); kickGain.gain.setTargetAtTime(m.kick,ctx.currentTime,.05); snrGain.gain.setTargetAtTime(m.snr,ctx.currentTime,.05); bassGain.gain.setTargetAtTime(m.bass,ctx.currentTime,.05); padGain.gain.setTargetAtTime(Math.min(0.12,m.pad*padBoost),ctx.currentTime,.20); }
    function schedule(){ if(!ctx) return; const bpm=baseTempo*(fever?1.16:1.0); while(nextNoteTime<ctx.currentTime+0.15){ scheduleStep(currentStep,nextNoteTime); const secPerBeat=60.0/bpm; nextNoteTime+=0.25*secPerBeat; currentStep=(currentStep+1)%16; } }
    function scheduleStep(step,t){ const lvl=levelFromCombo(comboInternal); if(patterns.hat[lvl][step]) playHat(t); if(patterns.kick[lvl][step]) playKick(t); if(patterns.snr[lvl][step]) playSnare(t); if(patterns.bass[lvl][step]) playBass(t,step); }
    function playHat(t){ const src=ctx.createBufferSource(); const buffer=ctx.createBuffer(1,(ctx.sampleRate*0.03)|0,ctx.sampleRate); const d=buffer.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1); src.buffer=buffer; const hp=ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000; const g=ctx.createGain(); g.gain.value=.0001; src.connect(hp).connect(g).connect(hatGain); src.start(t); g.gain.setValueAtTime(.0001,t); g.gain.linearRampToValueAtTime(.7,t+.002); g.gain.exponentialRampToValueAtTime(.0001,t+.06); }
    function playKick(t){ const o=ctx.createOscillator(); o.type='sine'; const g=ctx.createGain(); g.gain.value=.0001; o.frequency.setValueAtTime(140,t); o.frequency.exponentialRampToValueAtTime(42,t+.12); o.connect(g).connect(kickGain); o.start(t); g.gain.setValueAtTime(.0001,t); g.gain.linearRampToValueAtTime(1.0,t+.005); g.gain.exponentialRampToValueAtTime(.0001,t+.18); o.stop(t+.2); }
    function playSnare(t){ const src=ctx.createBufferSource(); const buffer=ctx.createBuffer(1,(ctx.sampleRate*0.18)|0,ctx.sampleRate); const d=buffer.getChannelData(0); for(let i=0;i<d.length;i++){ const env=1-i/d.length; d[i]=(Math.random()*2-1)*env; } src.buffer=buffer; const bp=ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800; bp.Q.value=.6; const g=ctx.createGain(); g.gain.value=.0001; src.connect(bp).connect(g).connect(snrGain); src.start(t); g.gain.setValueAtTime(.0001,t); g.gain.linearRampToValueAtTime(.9,t+.008); g.gain.exponentialRampToValueAtTime(.0001,t+.22); }
    function playBass(t,step){ const o=ctx.createOscillator(); o.type='sawtooth'; const g=ctx.createGain(); g.gain.value=.0001; const f=ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=360+(fever?140:0); const notes=[55,73.42,65.41]; const n=(step<8)?notes[0]:(step<12?notes[1]:notes[2]); o.frequency.setValueAtTime(n,t); o.connect(f).connect(g).connect(bassGain); o.start(t); g.gain.setValueAtTime(.0001,t); g.gain.linearRampToValueAtTime(.7,t+.02); g.gain.exponentialRampToValueAtTime(.0001,t+.28); o.stop(t+.32); }
    return { init, start, stop, resume, setEnabled(on){ _setEnabled(on); }, setTempo(){}, setFever(on){ _setFever(on); _setComboLevel(comboInternal); }, setComboLevel(combo){ _setComboLevel(combo); } };
  })();

  /* ========= 教學模式 ========= */
  function startTutorial(){
    if(state.tutorial.active) return;
    state.tutorial.active = true; state.tutorial.busy=false;
    toast("教學模式：系統將自動示範放置","#cfe");
    scheduleTutorialStep();
    renderHUD();
  }
  function stopTutorial(){
    if(!state.tutorial.active) return;
    state.tutorial.active=false; state.tutorial.busy=false;
    if(state.tutorial.timer) clearTimeout(state.tutorial.timer), state.tutorial.timer=null;
    clearGhost(); clearHighlight();
    toast("已退出教學模式","#ffd08a");
    renderHUD();
  }
  function scheduleTutorialStep(){
    if(!state.tutorial.active || state.gameOver || drag) return;
    if(state.usedThisSet>=3){ refillTrayFair(); }
    const b=bestPlacement();
    if(!b){ endGame(); return; }
    tutorialPlace(b);
  }
  function animateProxyTo(el, x, y, ms, easing){
    return new Promise(res=>{
      el.style.transition=`transform ${ms}ms ${easing}`;
      requestAnimationFrame(()=>{ el.style.transform = `translate(${x}px, ${y}px) scale(${el.dataset.scale})`; });
      setTimeout(()=>{ el.style.transition=''; res(); }, ms+30);
    });
  }
  async function tutorialPlace(best){
    if(state.tutorial.busy) return;
    state.tutorial.busy=true;

    clearGhost();
    best.p.cells.forEach(([dx,dy])=>{
      const rr = cellRectRel(best.x+dx, best.y+dy);
      if(!rr) return;
      const g=document.createElement("div");
      g.className="ghost-cell";
      g.style.left=px(rr.left); g.style.top=px(rr.top);
      g.style.width=px(rr.width); g.style.height=px(rr.height);
      ghostEl.appendChild(g);
    });

    const slot = document.querySelector(`.slot[data-index="${best.idx}"]`);
    const fromEl = slot?.querySelector('.piece');
    if(!fromEl){ state.tutorial.busy=false; return; }
    const proxy = fromEl.cloneNode(true);
    proxy.className="guide-proxy";
    document.body.appendChild(proxy);

    const rootCS = getComputedStyle(document.documentElement);
    const trayCell = parseFloat(rootCS.getPropertyValue('--tray-cell')) || 30;
    const gap = parseFloat(getComputedStyle(fromEl).gap) || 4;
    const naturalW = best.p.w * trayCell + (best.p.w - 1) * gap;
    const bboxW = fromEl.getBoundingClientRect().width;
    const scale = parseFloat(fromEl.dataset.scale) || (bboxW / naturalW);
    proxy.dataset.scale = scale;

    const mini = fromEl.querySelector('.cell-mini');
    const r0 = mini.getBoundingClientRect();
    proxy.style.transform = `translate(${r0.left}px, ${r0.top}px) scale(${scale})`;

    const targetRect = cellAt(best.x, best.y).getBoundingClientRect();
    await animateProxyTo(proxy, targetRect.left, r0.top, 180, 'cubic-bezier(.22,.61,.36,1)');
    await animateProxyTo(proxy, targetRect.left, targetRect.top, 360, 'cubic-bezier(.16,.84,.23,1)');

    proxy.remove();
    commitPlacement(best.p, best.idx, best.x, best.y);
    clearGhost();

    state.tutorial.busy=false;
    if(state.tutorial.active){
      state.tutorial.timer = setTimeout(scheduleTutorialStep, 420);
    }
  }

  /* ========= 事件 ========= */
  $("#btn-new").addEventListener("click", newGame);
  $("#btn-again").addEventListener("click", newGame);
  $("#btn-close").addEventListener("click", ()=> $("#overlayGameOver").classList.remove("show"));
  $("#btn-undo").addEventListener("click", ()=>{
    if(!state.history.length||state.undoCharges<=0) return;
    const prev=state.history.pop(); state.undoCharges--;
    state.board=prev.board; state.score=prev.score; state.tray=prev.tray; state.usedThisSet=prev.usedThisSet; state.streak=prev.streak; state.hold=prev.hold; state.fever=prev.fever; state.stats=prev.stats;
    renderBoard(); renderTray(); renderHUD(); saveState();
  });
  $("#btn-settings").addEventListener("click", ()=> $("#overlaySettings").classList.add("show"));
  $("#btn-close-settings").addEventListener("click", ()=>{ $("#overlaySettings").classList.remove("show"); state.settings.reduce = $("#opt-reduce").checked; state.settings.colorblind = $("#opt-colorblind").checked; state.settings.contrast = $("#opt-contrast").checked; state.settings.haptics = $("#opt-haptics").checked; state.settings.audio = $("#opt-audio").checked; saveSettings(); renderTray(); });
  $("#opt-contrast").addEventListener("change", e=>{ state.settings.contrast=e.target.checked; document.body.classList.toggle("high-contrast", e.target.checked); saveSettings(); });
  $("#opt-colorblind").addEventListener("change", e=>{ state.settings.colorblind=e.target.checked; renderTray(); saveSettings(); });
  $("#opt-hint").addEventListener("change", e=>{ state.settings.hint=e.target.checked; saveSettings(); });
  $("#opt-audio").addEventListener("change", e=>{ state.settings.audio=e.target.checked; music.setEnabled(state.settings.audio); saveSettings(); if(e.target.checked) music.resume(); });

  $("#btn-hold").addEventListener("click", ()=>{
    state.awaitingHold = !state.awaitingHold;
    toast(state.awaitingHold ? "點托盤任一方塊以暫存／交換" : "已退出暫存模式", state.awaitingHold?"#cfe":"#ffd08a");
  });

  $("#btn-shuffle").addEventListener("click", ()=>{
    if(!spendStars(1)) return; refillTrayFair(); state.lastActionAt=Date.now(); toast("托盤已重抽","#cfe");
  });

  $("#btn-hammer").addEventListener("click", ()=>{
    if(state.tools.hammer){ disableHammer(); return; }
    if(state.stars<=0){ toast("⭐ 不足","#ffd1d1"); return; }
    state.tools.hammer=true; boardEl.classList.add("hammer-cursor"); toast("點選任一格進行清除","#ffe49a");
  });
  function disableHammer(){ state.tools.hammer=false; boardEl.classList.remove("hammer-cursor"); }
  boardEl.addEventListener("click", (e)=>{
    if(!state.tools.hammer) return;
    const {gx,gy}=cellIndexFromPoint(e.clientX,e.clientY);
    if(gx<0||gy<0){ disableHammer(); return; }
    if(!state.board[gy][gx]){ toast("該格為空","#ffd1d1"); return; }
    if(!spendStars(1)) return;
    state.board[gy][gx]=null; renderBoard(); saveState(); disableHammer(); state.lastActionAt=Date.now();
    state.stats.hammer++; missionsAddProgress('hammer',1);
    toast("已清除 1 格","#cfe");
  });

  $("#btn-hint").addEventListener("click", showHint);

  $("#btn-daily").addEventListener("click", ()=>{
    const todaySeed=Number(new Date().toISOString().slice(0,10).replace(/-/g,'')); // YYYYMMDD
    RNG.useSeed(todaySeed); state.mode='daily'; newGame(); toast("每日挑戰開始","#cfe");
  });
  $("#btn-pass").addEventListener("click", ()=>{ RNG.useSystem(); state.mode='classic'; newGame(); toast("經典模式","#cfe"); });

  $("#btn-share").addEventListener("click", async ()=>{
    const shareData={ title:"Block Blast — Flow+ 版", text:`我在 Flow+ 版拿到 ${state.score} 分！` };
    try{ if(navigator.share){ await navigator.share(shareData); } else { await navigator.clipboard.writeText(`${shareData.title}\n${shareData.text}`); toast("已複製分享文字","#cfe"); } }
    catch{ toast("分享已取消","#ffd08a"); }
  });
  $("#btn-share-img").addEventListener("click", ()=> sharePoster());

  $("#btn-mission").addEventListener("click", ()=>{ missionsEnsureFresh(); renderMissionsUI(); $("#overlayMission").classList.add("show"); });
  $("#btn-close-mission").addEventListener("click", ()=> $("#overlayMission").classList.remove("show"));

  $("#btn-tutorial").addEventListener("click", ()=>{
    if(state.tutorial.active) stopTutorial(); else startTutorial();
  });

  window.addEventListener("keydown",(e)=>{
    if(e.key==='n'||e.key==='N') newGame();
    if(e.key==='u'||e.key==='U') $("#btn-undo").click();
    if(e.key==='h'||e.key==='H') showHint();
    if(e.key==='1'||e.key==='2'||e.key==='3'){
      const i=Number(e.key)-1; const slot=document.querySelector(`.slot[data-index="${i}"] .piece`);
      if(slot && !state.tutorial.active){ slot.dispatchEvent(new PointerEvent("pointerdown",{bubbles:true, clientX:window.innerWidth/2, clientY:window.innerHeight/2})); }
    }
    if(e.key==='Escape'){ clearGhost(); clearHighlight(); clearHint(); disableHammer(); stopTutorial(); state.awaitingHold=false; }
  });

  window.addEventListener('pointerdown', ()=>{ if(state.settings.audio) music.resume(); }, { once:true });

  function newGame(){
    if(state.settings.audio) music.resume();
    state.board=emptyBoard(); state.score=0; state.tray=[null,null,null]; state.usedThisSet=0; state.history=[]; state.gameOver=false;
    state.streak=0; setFeverMeter(0); document.body.classList.remove("is-fever"); state.undoCharges=3;
    clearGhost(); clearHighlight(); clearHint(); disableHammer(); state.awaitingHold=false;
    state.stats={ placed:0, lines:0, sessionScore:0, feverTriggers:0, starsGain:0, hammer:0, games:state.stats.games, maxCombo:0 };
    refillTrayFair(); renderBoard(); renderTray(); saveState(); state.lastActionAt=Date.now(); music.setComboLevel(0);
    if(state.tutorial.active){ stopTutorial(); }
  }
  function endGame(){
    state.gameOver=true; $("#finalScore").textContent=state.score; $("#overlayGameOver").classList.add("show");
    state.stats.games++; missionsAddProgress('games',1);
    announce(`遊戲結束。本局 ${state.score} 分。`);
    stopTutorial();
  }

  /* ========= Fullscreen Fit：直向防溢位 + 橫向 70%（左右各 35%） ========= */
  function updateVHVar(){
    const vh=(window.visualViewport?window.visualViewport.height:window.innerHeight)*0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  function setSizes(S){
    const root=document.documentElement.style;
    const trayCell=Math.max(22, Math.min(40, Math.round(S / 13)));
    root.setProperty('--board-size', `${Math.round(S)}px`);
    root.setProperty('--tray-cell', `${trayCell}px`);
    root.setProperty('--gap', `${Math.max(4, Math.round(S / 120))}px`);
    root.setProperty('--tile-radius', `${Math.max(6, Math.round(S / 70))}px`);
    requestAnimationFrame(fitTrayPieces);
  }
  function positionOverlayLayers(){
    const rect=boardEl.getBoundingClientRect();
    const wrap=boardWrap.getBoundingClientRect();
    const pad=parseFloat(getComputedStyle(boardEl).paddingLeft)||0;
    const L=rect.left-wrap.left+pad, T=rect.top-wrap.top+pad, W=rect.width-pad*2, H=rect.height-pad*2;
    $("#ghost").style.left=px(L); $("#ghost").style.top=px(T); $("#ghost").style.width=px(W); $("#ghost").style.height=px(H);
    $("#fx").style.left=px(L); $("#fx").style.top=px(T); $("#fx").style.width=px(W); $("#fx").style.height=px(H);
    const dpr=Math.min(2, window.devicePixelRatio||1); $("#fx").width=Math.round(W*dpr); $("#fx").height=Math.round(H*dpr);
    clearGhost(); clearHighlight();
  }

  function measurePortraitTotal(S){
    setSizes(S);
    positionOverlayLayers();
    const app = $(".app");
    const headerH = $("header").offsetHeight;
    const boardH  = $("#board").offsetHeight;
    const holdH   = $(".hold-row").offsetHeight;
    const trayH   = $("#tray").offsetHeight;
    const cs = getComputedStyle(app);
    const padTop = parseFloat(cs.paddingTop)||0;
    const padBot = parseFloat(cs.paddingBottom)||0;
    const rowGap = parseFloat(cs.rowGap)||10;
    const gaps = rowGap * 3;
    return headerH + boardH + holdH + trayH + gaps + padTop + padBot;
  }
  function fitPortraitTight(){
    const vw = window.innerWidth;
    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;

    const Smin = 240;
    const SmaxByW = vw * 0.94;
    const SmaxByRule = 720;
    let lo = Smin, hi = Math.floor(Math.min(SmaxByW, SmaxByRule, vh));
    let best = lo;

    let test = Math.floor(Math.min(vw*0.94, vh*0.82, 720));
    let total = measurePortraitTotal(test);
    if(total <= vh){ best = test; lo = test; }

    for(let i=0; i<14; i++){
      const mid = Math.floor((lo + hi) / 2);
      if(mid <= Smin){ best = Smin; break; }
      const sum = measurePortraitTotal(mid);
      if(sum <= vh){ best = mid; lo = mid + 1; }
      else{ hi = mid - 1; }
    }

    setSizes(best);
    positionOverlayLayers();
  }
  function fitLandscape(){
    const vw = window.innerWidth;
    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
    const SmaxByH = Math.min(860, vh * 0.90);
    const side = Math.max(320, Math.floor(vw * 0.35));   // 左/右欄各 35%
    const S    = Math.max(260, Math.min(SmaxByH, side)); // 棋盤不超過欄寬與高度上限
    document.documentElement.style.setProperty('--side-w', side + 'px');
    setSizes(S);
    positionOverlayLayers();
  }
  function fitLayout(){
    updateVHVar();
    const vw = window.innerWidth;
    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
    const isLandscape = (vw >= 900 && vw / vh >= 1.25);
    if(isLandscape) fitLandscape();
    else            fitPortraitTight();
  }
  const fitLayoutRAF = rafBatch(fitLayout);
  function bindFitEvents(){
    const rerun=()=>{ if(layoutFreeze) rafBatch(ensureOverlaySync)(); else fitLayoutRAF(); };
    window.addEventListener('resize', rerun, {passive:true});
    window.addEventListener('orientationchange', rerun, {passive:true});
    if(window.visualViewport){
      window.visualViewport.addEventListener('resize', rerun, {passive:true});
      window.visualViewport.addEventListener('scroll', rerun, {passive:true});
    }
    if(document.fonts && document.fonts.ready) document.fonts.ready.then(rerun);
    rerun();
  }

  /* ========= 基本放置判定 ========= */
  function canPlace(piece,x,y){
    for(const [dx,dy] of piece.cells){
      const cx=x+dx, cy=y+dy;
      if(cx<0||cx>=SIZE||cy<0||cy>=SIZE) return false;
      if(state.board[cy][cx]) return false;
    }
    return true;
  }

  /* ========= 啟動 ========= */
  missionsLoad();
  const loaded=loadState(); if(!loaded) refillTrayFair();
  renderBoard(); renderTray(); if(feverFill) feverFill.style.setProperty('--fever', state.fever.meter/100);
  bindFitEvents();
  music.setEnabled(state.settings.audio);

  /* ========= FPS Denoise：1 秒平均 <45fps 開啟、>52fps 關閉 ========= */
  // === FPS Denoise
  (function fpsDenoise(){
    const samples=[]; let last=performance.now();
    function loop(t){
      const dt=t-last; last=t;
      const fps=1000/dt; samples.push(fps); if(samples.length>60) samples.shift();
      const avg=samples.reduce((a,b)=>a+b,0)/samples.length;
      if(avg<45) document.body.classList.add('lowfx');
      else if(avg>52) document.body.classList.remove('lowfx');
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  })();

})();
</script>
</body>
</html>
